---
layout: post
title: Solidity-åŸºç¡€
date: 2022-07-13 16:45:30.000000000 +09:00
tag: Solidity
---


## Solidity åˆè¯†
Solidity æ˜¯ä¸€ä¸ªé¢å‘å¯¹è±¡çš„è¯­è¨€

{% highlight ruby %}
pragma solidity^0.6.0 // ç¼–è¯‘å™¨ç‰ˆæœ¬ï¼Œå‘ 0.6.x å…¼å®¹çš„ 
// ä¹Ÿå¯ä»¥å†™æˆ pragma solidity >=0.7.0 <0.9.0 å³ç¼–è¯‘å™¨ç‰ˆæœ¬åœ¨ 0.7.0~0.9.0

// hello ä¸ºåˆçº¦åå­—
contract hello {
    // å®šä¹‰çŠ¶æ€å˜é‡ï¼Œå°†ä¼šå­˜æ”¾åœ¨ä»¥å¤ªåŠä¸–ç•ŒçŠ¶æ€æ ‘ä¸­ï¼Œå…¨çƒè®¡ç®—æœºéƒ½ä¼šä¸ºä½ ä¿å­˜è¯¥å˜é‡
    string hellomsg; // æ€è€ƒï¼šå­˜æ”¾åœ¨å“ªé‡Œï¼Ÿ

    constructor(string memory _msg) public {
        hellomsg = _msg;
    }

    // è®¾ç½®æ¶ˆæ¯
    function setMsg(string memory _msg) public {
        hellomsg = _msg;
    }

    // è·å–æ¶ˆæ¯
    function getMsg() public view returns (string memory) {
        return hellomsg;
    }
}
{% endhighlight %}
* hellomsg å«çŠ¶æ€å˜é‡ï¼Œä»¥å¤ªåŠä¸­æœ‰ä¸ªä¸–ç•ŒçŠ¶æ€æ ‘ï¼Œä¸–ç•ŒçŠ¶æ€æ ‘å­˜æ”¾ä¸–ç•ŒçŠ¶æ€ï¼Œè€Œ hellomsg å°±æ˜¯æœ€ç»ˆå­˜æ”¾åœ¨ä¸–ç•ŒçŠ¶æ€æ ‘é‡Œ
* constructor æ„é€ å‡½æ•°ï¼ˆéƒ¨ç½²æ—¶å€™è¢«æ‰§è¡Œï¼‰ï¼Œå¯¹äº string æˆ–æ•°ç»„ç¼–è¯‘å™¨éƒ½ä¼šè®©åŠ ä¸Š memory
* public å³å‡½æ•°çš„è®¿é—®æƒé™
* 0xd9145CCE52D386f254917e481eB44e9943F39138 åˆçº¦åœ°å€ï¼Œå’Œæ™®é€šè´¦æˆ·åœ°å€ä¸€æ ·ï¼Œéƒ½æ˜¯ address ç±»å‹æ•°æ®
* Deploy å³è°ƒç”¨æ„é€ å‡½æ•°
* gas = gas cost * gas price 


### DEPLOY & RUN TRANSACTIONS 
1. JavaScript VM å³ æµè§ˆå™¨å†…ç½®è™šæ‹Ÿæœºç¯å¢ƒ
2. Web3 Provider éƒ¨ç½²åˆ°èŠ‚ç‚¹ï¼Œå¦‚æœè‡ªå·±æœ¬æœºè·‘ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆè´¦æˆ·èƒ½çœ‹åˆ°


### å¯åŠ¨ä¸€ä¸ª geth æœ¬åœ°èŠ‚ç‚¹ç”¨äºæµ‹è¯•
* å¯ä»¥ geth æœ¬åœ°å¯åŠ¨ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆæ“ä½œè§ä¹‹å‰çš„æ–‡ç« ï¼‰
* é€‰æ‹© External http Providerï¼Œä¸€èˆ¬æ˜¯æœ¬æœº 8545 ç«¯å£ï¼Œå¦‚æœèŠ‚ç‚¹å·²å¯åŠ¨è¿æ¥ä¸ä¸Š Remix çœ‹ä¸‹æ˜¯å¦ç”¨äº†ä»£ç†ğŸ˜‚
* éƒ¨ç½² hello åˆçº¦ï¼Œå¦‚æœå‡ºç°è´¦æˆ·è¢«é” authentication needed: password or unlock
* éœ€è¦è§£é” personal.unlockAccount(acc1)ï¼Œéœ€è¦è¾“å…¥å¯†ç 
* è¿™æ—¶å†éƒ¨ç½²ï¼Œå‘ç°ä¼šå˜æ…¢ï¼Œæ˜¯å› ä¸ºè¦ç­‰å¾…æŒ–çŸ¿ï¼Œä»¥å¤ªåŠä¸€èˆ¬æ˜¯ 10 å‡ ç§’


## Solidity æ•°æ®ç±»å‹
* string å­—ç¬¦åºåˆ—ï¼Œä½¿ç”¨ UTF-8 ç¼–ç 
* bool å¸ƒå°”ç±»å‹ï¼Œtrueã€false
* int æœ‰ç¬¦å·æ•´æ•°ï¼Œç”±äºæ™ºèƒ½åˆçº¦è€ƒè™‘å­˜å‚¨ï¼Œä¸€ä¸ªå­—èŠ‚å°±æ˜¯ä¸€ä¸ªç±»å‹ï¼Œæœ‰ int8ï¼Œint16 ç­‰
* uint æ— ç¬¦å·æ•´æ•°ï¼Œä¸èƒ½è¡¨ç¤ºè´Ÿæ•°
* address åœ°å€ï¼Œç”¨æ¥è¡¨ç¤ºè´¦æˆ·æˆ–æ™ºèƒ½åˆçº¦ï¼Œå¯ä»¥ç”¨æ¥è½¬è´¦ï¼Œä¾‹å¦‚ 0xd9145CCE52D386f254917e481eB44e9943F39138

{% highlight ruby %}
pragma solidity^0.6.0;

contract simpleDataType {
    // å®šä¹‰çŠ¶æ€å˜é‡
    // public ç±»å‹çš„å˜é‡è‡ªåŠ¨æä¾›æŸ¥è¯¢æ–¹æ³•
    string public name;
    uint8 public age;
    string public job;
    int256 salary;


    // å­—èŠ‚ç±»å‹ bytes32 æ˜¯å“ˆå¸Œå€¼è¿”å›ç»“æœ
    bytes32 public personHash;

    // æ„é€ å‡½æ•°
    constructor(string memory _name, uint8 _age, string memory _job, int256 _salary) public {
        name = _name;
        age = _age;
        job = _job;
        salary = _salary;
        
        // keccak256 ä»¥å¤ªåŠçš„å“ˆå¸Œè®¡ç®—å‡½æ•°
        // ä¹‹å‰ç‰ˆæœ¬å¯ä»¥ä¼ å¤šä¸ªå‚æ•°ï¼Œå‡çº§ååªèƒ½ä¼ ä¸€ä¸ªå‚æ•°ï¼Œè¿™æ—¶æˆ‘ä»¬éœ€è¦ä½¿ç”¨ abi.encode ç¼–ç è¿›è¡Œç¼–ç 
        // 0x8f1646852a221db355f721f1a6bf3010f0c3cc9d897b19fe178fd0d93d93b8a2
        personHash = keccak256(abi.encode(name, age, job, salary));
    }

    function getSalary() public view returns (int256) {
        return salary;
    }
}
{% endhighlight %}
* public ç±»å‹çš„å˜é‡è‡ªåŠ¨æä¾›æŸ¥è¯¢æ–¹æ³•


## å†…å»ºå¯¹è±¡ block
* block.coinbase (address): å½“å‰å—çš„çŸ¿å·¥çš„åœ°å€
* block.difficulty (uint): å½“å‰å—çš„éš¾åº¦ç³»æ•°
* block.gaslimit (uint):å½“å‰å— gas çš„ä¸Šé™
* block.number (uint): å½“å‰å—ç¼–å·
* block.blockhash (function (uint) returns (bytes32)): å‡½æ•°ï¼Œè¿”å›æŒ‡å®šå—çš„å“ˆå¸Œå€¼ï¼Œå·²ç»è¢«å†…å»ºå‡½æ•° blockhash æ›¿ä»£
* block.timestamp (uint): å½“å‰å—çš„æ—¶é—´æˆ³ï¼Œç­‰åŒäº nowï¼Œå³ç³»ç»Ÿå½“å‰æ—¶é—´ï¼Œç§’æ•°

## å†…å»ºå¯¹è±¡ msgï¼ˆæ¯” block è¿˜é‡è¦ï¼‰
Remix é‡Œçš„è¿è¡Œæ—¶çš„å€¼å°±æ˜¯ msg çš„ä¿¡æ¯ï¼Œæ¯”å¦‚ account æ˜¯å“ªä¸ªè´¦æˆ·æ‰§è¡Œçš„å³ msg.sender
* msg.data (bytes): å®Œæ•´çš„ calldataï¼Œå³ msg çš„å…¨éƒ¨ä¿¡æ¯
* msg.gas (uint): å‰©ä½™çš„ gas é‡
* msg.sender (address): æ¶ˆæ¯å‘é€æ–¹ï¼ˆå³è°ƒç”¨è€…ï¼‰ï¼Œè¿™ä¸ªå¾ˆé‡è¦
* msg.sig (bytes4): calldata çš„å‰ 4 ä¸ªå­—èŠ‚ï¼ˆå³å‡½æ•°æ ‡è¯†ç¬¦ï¼‰ï¼Œæ¯ä¸ªå‡½æ•°å–å‰ 4 ä¸ªå­—èŠ‚éƒ½å¯ä»¥æ‹¿åˆ°ä¸€ä¸ªå‡½æ•°æ ‡è¯†
* msg.value (uint): æ‰€å‘é€çš„æ¶ˆæ¯ä¸­ weiï¼ˆä»¥å¤ªåŠæ¿€åŠ±ä½“ç³»å†…æœ€å°çš„è™šæ‹Ÿæ•°å­—è´§å¸å•ä½ï¼‰çš„æ•°é‡ï¼Œå°±æ˜¯çœŸé‡‘ç™½é“¶ï¼Œè¿™ä¸ªæ¯”è¾ƒé‡è¦

## è®¡ç®—éšæœºæ•° Demo
{% highlight ruby %}
pragma solidity^0.6.0;

contract random_demo {
    function getRandom() public view returns (uint256) {
        // è®¡ç®—ä¸€ä¸ª100ä»¥å†…çš„éšæœºæ•°
        // æ ¹æ®å“ˆå¸Œé˜²ç¢°æ’çš„ç‰¹æ€§ï¼Œè¾“å…¥ä¸åŒï¼Œäº§ç”Ÿä¸åŒè¾“å‡ºï¼Œå°±æ˜¯éšæœºå€¼
        // now å½“å‰æ—¶é—´
        bytes32 hash = keccak256(abi.encode(now, msg.sender, block.number, "salt"));
        
        return uint256(hash) % 100;
    }
}
{% endhighlight %}


## å‡½æ•°
### æ ¼å¼
function funcName(paramlist...) modifiers returns (returnlist...)

* function æ˜¯å‡½æ•°å£°æ˜å…³é”®å­—
* funcName è‡ªå®šä¹‰å‡½æ•°åç§°ï¼Œä¸æˆ‘ä»¬ä¹ æƒ¯çš„å‡½æ•°å‘½åè§„èŒƒæ²¡æœ‰åŒºåˆ«
* paramlist å³å‚æ•°åˆ—è¡¨ï¼šå¯ä»¥ 0 ä¸ªæˆ–å¤šä¸ªï¼Œæ ¼å¼æ˜¯ å‚æ•°ç±»å‹ å‚æ•°åç§°
* modifiers å‡½æ•°çš„ä¿®é¥°ç¬¦ï¼Œéå¸¸å…³é”®ï¼Œæ¯”å¦‚ publicã€view éƒ½æ˜¯ä¿®é¥°ç¬¦
* returns è¿”å›å€¼å…³é”®å­—ï¼Œå¯è¿”å›å¤šä¸ªè¿”å›å€¼
* returnlist è¿”å›å€¼ç±»å‹åˆ—è¡¨


### ä¾‹å­ 1+2+3...+100
{% highlight ruby %}
pragma solidity^0.6.0;

contract function_deom {
    // è®¡ç®— 1+2+3...+100=5050
    // è¿”å›å€¼å®šä¹‰åå­— result 
    function getSum() public pure returns (uint256 result) {
        uint256 sum = 0; // ä¸´æ—¶å˜é‡
        uint256 i = 0;
        // init; cond; post
        for (i = 1; i < 101; i++) {

            sum += i;

        }
        // å®šä¹‰è¿”å›å€¼åç§°å¯ä¸å†™ return
        result = sum;
      //  return sum;
    }

    // æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰
    function isEqualToString(string memory a, string memory b) public pure returns (bool, bytes32) {

        bytes32 hashSpace = keccak256(abi.encode(""));

        // solidity ä¸­æ²¡æœ‰å¯¹ == è¿ç®—ç¬¦è¿›è¡Œé‡è½½
        // æ€è·¯ï¼šå€ŸåŠ© hash å‡½æ•°ï¼Œå¦‚æœ hash(a) == hash(b) ===> a == b
        bytes32 hashA = keccak256(abi.encode(a));
        bytes32 hashB = keccak256(abi.encode(b));

        bytes32 memory hashAA = bytes(a)
        bytes32 memory hashBB = bytes(b)


        // if (hashA == hashSpace || hashB == hashSpace) {
        //     return false;
        // }

        
        return hashA == hashB;
    }
}

    // é€šè¿‡ length è§£å†³ç©ºè¾“å…¥ç›¸ç­‰é—®é¢˜
    // æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰
    function isEqualToString(string memory a, string memory b) public pure returns (bool) {
        // å¯ä»¥å…ˆè®¡ç®—å­—ç¬¦ä¸²é•¿åº¦ï¼Œå¦‚æœé•¿åº¦ä¸º 0 åˆ™ä¸å…è®¸è®¡ç®—


        // hashA å®é™…æ˜¯ä¸€ä¸ªæ•°ç»„, é€šè¿‡ bytes æŠŠå­—ç¬¦ä¸²è½¬æˆæ•°ç»„
        bytes memory hashA = bytes(a);
        bytes memory hashB = bytes(b);

        if (hashA.length == 0 || hashB.length == 0) {
            return false;
        }
        bytes32 hashAA = keccak256(hashA);
        bytes32 hashBB = keccak256(hashB);


        
        return hashAA == hashBB;
    }
{% endhighlight %}
* solidity ä¸­æ²¡æœ‰å¯¹è¿ç®—ç¬¦è¿›è¡Œé‡è½½

## å‡½æ•°ä¿®é¥°ç¬¦

ä¿®é¥°ç¬¦|æ„ä¹‰| åˆ†ç±»
public|ä»»ä½•äººå¯ä»¥è°ƒç”¨è¯¥å‡½æ•°ï¼Œæƒé™æœ€å¤§ï¼Œå†…éƒ¨å¤–éƒ¨éƒ½å¯è°ƒç”¨ï¼Œä¸ private äº’æ–¥|è°ƒç”¨æ§åˆ¶ç±»
private|åªæœ‰è¯¥åˆçº¦æ‰èƒ½è°ƒç”¨ï¼ˆonly å†…éƒ¨è°ƒç”¨ï¼‰ï¼Œä¸ public äº’æ–¥|è°ƒç”¨æ§åˆ¶ç±»
external|å¤–éƒ¨å‡½æ•°ï¼›å†…éƒ¨ä¸èƒ½è®¿é—®ï¼Œå¤–éƒ¨æ­£å¸¸è®¿é—®ï¼Œâ€œå­ç±»å¯ç»§æ‰¿â€ï¼Œå®šä¹‰æ¥å£æ—¶ç”¨|è°ƒç”¨æ§åˆ¶ç±»
internal|å†…éƒ¨å‡½æ•°ï¼›å†…éƒ¨æ­£å¸¸è®¿é—®ï¼Œå¤–éƒ¨æ— æ³•è®¿é—®ï¼Œâ€œå­ç±»å¯ç»§æ‰¿â€|è°ƒç”¨æ§åˆ¶ç±»
constant|åˆçº¦ä¸ä¿®æ”¹çŠ¶æ€å˜é‡ï¼Œå’Œ view ä¸€æ ·ï¼Œè¿‡æœŸäº†ç”¨ view æ›¿ä»£|çŠ¶æ€å˜é‡è®¿é—®æ§åˆ¶ç±»
view|åˆçº¦ä¸ä¿®æ”¹çŠ¶æ€å˜é‡ï¼Œä¸ constant ä¸€æ ·|çŠ¶æ€å˜é‡è®¿é—®æ§åˆ¶ç±»
pure|åˆçº¦å³ä¸ä¿®æ”¹ä¹Ÿä¸è¯»å–çŠ¶æ€å˜é‡|çŠ¶æ€å˜é‡è®¿é—®æ§åˆ¶ç±»
payable|æ¶‰åŠä»¥å¤ªå¸è½¬ç§»ï¼Œå¯ä¿®é¥°å‡½æ•°å’Œ address|èµ„é‡‘æ§åˆ¶ç±»
è‡ªå®šä¹‰ä¿®é¥°ç¬¦|æ”¯æŒè‡ªå®šä¹‰ä¿®é¥°ç¬¦ï¼Œè·Ÿæ•°æ®åº“äº‹åŠ¡æ§åˆ¶æœ‰å…³ï¼Œæ¶‰åŠ requireã€assert|è‡ªå®šä¹‰æ§åˆ¶ç±»


* publicã€private æ˜¯ä¸€ç»„
* externalã€internal æ˜¯ä¸€ç»„
* viewã€constantã€pure æ˜¯ä¸€ç»„



ä¿®é¥°ç¬¦ Demo

{% highlight ruby %}
pragma solidity^0.6.0;

contract modifiers_demo {
    // æ¼”ç¤ºä¸‰ç§ä¸åŒæ¼”ç¤ºçš„å‡½æ•°
    uint256 totalAmount;
    
    constructor() public {
        totalAmount = 0;
    }

    // çº¢é¢œè‰²çš„å‡½æ•°ï¼šå¸¦ payable
    // æ¶ˆè€— gas + eth
    function payamount() public payable {
        totalAmount -= 10;

    }

    // æ©˜çº¢è‰²çš„å‡½æ•°: ä¿®æ”¹çŠ¶æ€å˜é‡çš„å‡½æ•°
    // åªæ¶ˆè€— gas
    function setAmount(uint256 amount) public {
        totalAmount = amount;
    }

    // è“è‰²çš„å‡½æ•°ï¼šå¸¦ viewã€pure æ˜¯è“è‰²çš„
    // æ— æ¶ˆè€—
    function getAmount() public view returns (uint256) {
        return totalAmount;
    }
}
{% endhighlight %}


## å……å€¼ä¸æç°
1. å……å€¼
* å‡½æ•° + payable
* å…³é”®ï¼šmsg.value å¤§äº 0

2. æç°
* åœ°å€ + payable
* address.transfer(uint256 amount)
* æˆ–ä½¿ç”¨ address.send

{% highlight ruby %}
pragma solidity^0.6.0;

contract deposit_demo {
    address owner;

    constructor() public {
        owner = msg.sender; // msg.sender ä»£è¡¨è°ƒç”¨è€…
    }

    // å……å€¼
    function deposit() public payable {

    }

    // æç°
    function withdraw(uint256 amount) public payable {
        // æ–¹å¼ä¸€
        // æ¨èä½¿ç”¨ transferï¼Œtransfer æ¯” send æ¶ˆè€—çš„ gas æ›´å°‘
        msg.sender.transfer(amount);
        
        // æ–¹å¼äºŒ
         msg.sender.send(amount);

    }

    // æŸ¥è¯¢åˆçº¦ä½™é¢
    // this å¯ä»¥ç†è§£ä¸ºæ˜¯æœ¬åˆçº¦
    // address(this) åˆçº¦å¼ºè½¬ä¸º address å¯¹è±¡
    // address å†…éƒ¨å±æ€§ balanceï¼Œè·å–è´¦æˆ·ä½™é¢
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
{% endhighlight %}

## å¤åˆç±»å‹
* T[N] å®šé•¿æ•°ç»„ï¼Œlength è¡¨ç¤ºæ•°é‡
* T[]  åŠ¨æ€æ•°ç»„ï¼Œlength è¡¨ç¤ºæ•°é‡ï¼Œ push æ¨å…¥
* struct ç»“æ„ä½“
* mapping(T1 => T2) æ˜ å°„è¡¨
* bytesN å­—èŠ‚æ•°ç»„

### æ•°ç»„
* æ•°ç»„å³å­˜å‚¨ç›¸åŒç±»å‹å…ƒç´ ï¼Œå…ƒç´ åœ¨å†…å­˜æ˜¯è¿ç»­å­˜æ”¾çš„
* é€šè¿‡ push æ·»åŠ å…ƒç´ ï¼Œä¸€èˆ¬ä¸åˆ é™¤ï¼Œå› ä¸ºåˆ é™¤äº†é‚£ä¸ªå¯¹è±¡è¿˜æ˜¯ä¼šå ç”¨é‚£ä¸ªç´¢å¼•ä½ç½®
* è‹¥çœŸæƒ³åˆ é™¤å¯ä»¥å°†æœ€åä¸€ä¸ªå…ƒç´ æ›¿æ¢æ‰æƒ³åˆ é™¤çš„ indexï¼Œç„¶åå†æŠŠæœ€åä¸€ä¸ªå…ƒç´ åˆ æ‰
{% highlight ruby %}
pragma solidity^0.6.0;
pragma experimental ABIEncoderV2;

contract array_demo {
    string[3] names; // å®šé•¿æ•°ç»„
    uint256[] ages;  // åŠ¨æ€æ•°ç»„
    
    constructor() public {
        names[0] = "tom"; // å¯¹æ•°ç»„çš„è®¿é—®ï¼Œå°±æ˜¯[ä¸‹æ ‡]ï¼Œæ³¨æ„ä¸è¦è¶Šç•Œ
        names[1] = "Jack";

        // ages[0] = 10; åŠ¨æ€æ•°ç»„ä¸å…è®¸è®¿é—®ä¸å­˜åœ¨çš„ä¸‹æ ‡
        ages.push(10); // é€šè¿‡ push æ·»åŠ å…ƒç´ 
        ages[0] = 20;  // ä¸‹æ ‡ 0 æœ‰å…ƒç´ åæ‰å¯è®¿é—®
    }

    function setNames(string memory name, uint256 index) public {
        names[index] = name;
    }

    function setAges(uint256 age) public {
        ages.push(age);
    }

    function getLength() public view returns (uint256, uint256) {
        return (names.length, ages.length);
    }

    // ç¼–è¯‘æŠ¥é”™ä¸æ¨èè¿™ä¹ˆå†™ï¼ŒåŠ ä¸Š pragma experimental ABIEncoderV2; å¯ç¼–è¯‘é€šè¿‡
    function getAllNames() public view returns (string[3] memory) {
        return names;
    }
}
{% endhighlight %}

### struct
{% highlight ruby %}
pragma solidity^0.6.0;
pragma experimental ABIEncoderV2;


// å®šä¹‰ç»“æ„ï¼Œ0.6 åç»“æ„å®šä¹‰å¯ä»¥æ”¾åœ¨åˆçº¦å¤–äº†ï¼Œ 
struct Person {
    string name;
    uint8 age;
    bool isMan;
    uint256 salary;
}

contract struct_demo {
    Person[] persons;
    // æ„é€  person å¯¹è±¡

    constructor() public {

    }

    function addPerson(string memory name_, uint8 age_, bool man_, uint256 salary_) public {
        Person memory p = Person(name_, age_, man_, salary_);
        persons.push(p);
    }

    function findPerson(uint256 index) public view returns (Person memory) {
        return persons[index];
    }

    function setAge(uint256 index, uint8 a) public {
         Person memory p = persons[index]; 
         p.age = a;  // ä¿®æ”¹æ— æ•ˆ

    }

    function setAge2(uint256 index, uint8 a) public {
        persons[index].age = a; // ä¿®æ”¹æœ‰æ•ˆ

    }

    function setAge3(uint256 index, uint8 a) public {
        /*  Note
            æœ¬åœ°å˜é‡å°±ä¸¤ç§é€‰æ‹© memory æˆ– storage
            memory ç›¸å½“äºå€¼ä¼ é€’ï¼Œå€¼æ‹·è´ï¼Œæ‹·è´åå¾—åˆ°çš„å¯¹è±¡ä¸åŸå¯¹è±¡æ²¡æœ‰ä¸€ç‚¹å…³ç³»
            storage ç›¸å½“äºå¼•ç”¨ä¼ é€’ï¼ŒæŒ‡é’ˆèµ‹å€¼ï¼Œèµ‹å€¼åå¾—åˆ°çš„å¯¹è±¡ä¼šå½±å“åŸå¯¹è±¡
        */
         Person storage p = persons[index]; // ä¿®æ”¹æœ‰æ•ˆ
         p.age = a;

    }
}

{% endhighlight %}

### mapping
é€šè¿‡ key-value è¿›è¡Œå­˜å‚¨
{% highlight ruby %}
pragma solidity^0.6.0;
pragma experimental ABIEncoderV2;

// å­¦ç”Ÿç»“æ„
struct Student {
    string name;
    string sex;
    uint8 age;

}

contract mapping_demo {
    // å­¦ç”Ÿç¼–å·ä½œä¸º keyï¼ŒæŒ‡å‘å­¦ç”Ÿä¿¡æ¯
    mapping(uint256=>Student) students;
    uint256 count;

    constructor() public {
        count = 0;
    }

    function addStudent(string memory n, string memory s, uint8 a) public {
        Student memory stu = Student(n, s, a);
        // mapping çš„è®¿é—®æˆ–ä¿®æ”¹ éƒ½æ˜¯é€šè¿‡ key
        students[0] = stu;
    }


    function getStudent(uint256 index) public view returns (Student memory) {
        // å¦‚æœ key å¯¹åº”çš„ value æ²¡æœ‰ï¼Œä¼šæ‰¾ä¸åˆ°ï¼Œä¸ä¼šåƒæ•°ç»„è¶Šç•Œ
        return students[index];
    }
}
{% endhighlight %}

## æ–­è¨€å’Œé”™è¯¯å¤„ç†
è¦ä¹ˆå…¨æˆåŠŸï¼Œè¦ä¹ˆå…¨å¤±è´¥

* æ–­è¨€å’Œé”™è¯¯å¤„ç†å‘ç”Ÿæ—¶ï¼šé€€å›åˆå§‹çŠ¶æ€
* assertï¼šæ¯”è¾ƒæ®‹æš´ï¼Œæ‰£å…‰ gas
1. ç”¨äºå†…éƒ¨å˜é‡åˆ¤æ–­
2. ç”¨äº pure å‡½æ•°
3. ç”¨äºæ£€æµ‹ç³»ç»Ÿé”™è¯¯
* requireï¼šé€€è¿˜å‰©ä½™ gasï¼Œç”¨äºåˆ¤æ–­ä¸šåŠ¡é€»è¾‘

é€‚åˆ asset çš„æƒ…å†µï¼š
* ç”¨äºå†…éƒ¨å˜é‡åˆ¤æ–­
* ç”¨äº pure å‡½æ•°
* ç”¨äºæ£€æµ‹ç³»ç»Ÿé”™è¯¯

{% highlight ruby %}
pragma solidity^0.6.0;

contract require_deom {
    uint256 count;

    constructor() public {
        count = 30;
    }

    function setCount(uint256 c) public {
        // assert(cond) å¦‚æœæ¡ä»¶ä¸æˆç«‹ï¼Œåˆ™æŠ¥é”™å¹¶ä¸”æ‰£å…‰ gas, çŠ¶æ€å›é€€
        count = 25;
        assert(c > count);
     //   count = c;
    }

    function setCount2(uint256 c) public {
        // require(cond), å¦‚æœæ¡ä»¶ä¸æˆç«‹ï¼Œåˆ™æŠ¥é”™å¹¶é€€å‡º
        count = 26;
        require(c > count, "c must bigger than count");
        count = c;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}
{% endhighlight %}

## è‡ªå®šä¹‰ä¿®é¥°ç¬¦
è‡ªå®šä¹‰ä¿®é¥°ç¬¦ç”¨äºå°†å¤šä¸ªæ¡ä»¶ç»„åˆåœ¨ä¸€èµ·ï¼Œé‡å¤åˆ©ç”¨

{% highlight ruby %}
æ ¼å¼
modifier modifier_name(å‚æ•°,å¯ä¸ä¼ ) {
  require(cond, "cond error text");  // æ¡ä»¶ï¼Œå¯ä»¥æœ‰å¤šä¸ªæ¡ä»¶
  ...
  _; å ä½ç¬¦å·ï¼Œæ ‡è¯† modifier çš„ç»“æŸ
}
{% endhighlight %}

ç”¨æ³•ï¼šå‡½æ•°å£°æ˜ç”¨è¿‡ modifier_nameï¼Œå‡½æ•°æ‰§è¡Œå‰ä¼šå…ˆæ‰§è¡Œ modifier_name çš„æ¡ä»¶

{% highlight ruby %}
pragma solidity^0.6.0;

contract only_admin_demo {
    address admin; // ç®¡ç†å‘˜
    uint256 count;
    constructor(address owner) public {
        admin = owner;
        count = 30;
    }

    // è‡ªå®šä¹‰ä¿®é¥°ç¬¦
    modifier onlyOwner() {  
        require(msg.sender == admin, "only admin can do it!");
        _; // å ä½ç¬¦
    }
    // å£°æ˜å‡½æ•°æ—¶å€™åŠ ä¸Š onlyOwner ä¿®é¥°ç¬¦ï¼Œåªæœ‰ç®¡ç†å‘˜å¯ä»¥æ”¹ count
    function setCount(uint256 c) public onlyOwner { 
        count = c;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}
{% endhighlight %}

### å…¶ä»–ä¾‹å­
* Note å¸¦  msg.value å’Œ transfer éœ€è¦  payable
{% highlight ruby %}
// å»è°ƒè­¦å‘Š
// SPDX-License-Identifier:Apache-2.0
pragma solidity^0.8.7;

// deposit  withdraw.  transfer
// è´¦æœ¬è®°å½• 
contract bank {

    address owner;
    // å‚¨æˆ·å¾ˆå¤šäºº æ— æ³•å®šä¹‰å˜é‡
    
    mapping(address=>uint256) _balances; // å‚¨æˆ·è´¦æœ¬
    string public bankName;
    uint256 public totalAmount;

    constructor(string memory _name) {
        owner = msg.sender;
        bankName = _name;
    }
    // å­˜æ¬¾ å–æ¬¾ è½¬è´¦
    function deposit(uint256 _amount) public payable {
        require(_amount > 0, "amount must > 0");

        require(msg.value == _amount, "amount not equal value");

        _balances[msg.sender] += _amount;

        totalAmount += _amount;
        // åˆçº¦è´¦å·çš„é’± address(this).balance
        require(totalAmount == address(this).balance);



    }
        // å¸¦  msg.value å’Œ transfer éœ€è¦  payable

    function withdraw(uint256 _amount) public payable {
        require(_amount > 0, "amount must > 0");
        require(_balances[msg.sender] >= _amount, "user's balance not enough");

        _balances[msg.sender] -= _amount;
        payable(msg.sender).transfer(_amount);
        totalAmount -= _amount;
        require(totalAmount == address(this).balance);
    
    }

    function transfer(address to, uint256 _amount) public  {
        // require è§£å†³äº‹åŠ¡é—®é¢˜
        require(_amount > 0, "amount must > 0");
        require(_balances[msg.sender] >= _amount, "user's balance not enough");
        // åœ°å€æ˜¯å¦æœ‰æ•ˆ
        require(address(0) != to, "to is invalid");
        
        _balances[to] += _amount;
        _balances[msg.sender] -= _amount;
        require(totalAmount == address(this).balance);

    }

    function getBalance(address _who) public view returns (uint256) {
        return _balances[_who];
    }
}
{% endhighlight %}

### msg.sender VS tx.origin
å…¬é“¾ä¸Šæ¨èä½¿ç”¨ msg.senderï¼Œå› ä¸º tx.origin è¡¨ç¤ºæœ€åˆçš„è°ƒç”¨è€…ï¼Œå®¹æ˜“è¢«æ”»å‡»è€…åˆ©ç”¨
