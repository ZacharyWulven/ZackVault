---
layout: post
title: RustGuide-16-AdvanceCharacter
date: 2023-04-10 16:45:30.000000000 +09:00
categories: [Rust, Rust Getting Start]
tags: [Rust, Rust Getting Start]
---

# 19 é«˜çº§ç‰¹æ€§

## Unsafe Rustï¼ˆä¸å®‰å…¨ Rustï¼‰

### åŒ¹é…å‘½åå˜é‡
* åœ¨ Rust ä¸­éšè—ç€ç¬¬äºŒä¸ªè¯­éŸ³ï¼Œå®ƒæ²¡æœ‰å¼ºåˆ¶å†…å­˜å®‰å…¨ä¿è¯ï¼Œå®ƒå°±æ˜¯ `Unsafe Rust`
* `Unsafe Rust` ä¸æ™®é€šçš„ Rust ä¸€æ ·ï¼Œä½†æä¾›äº†ä¸€äº› â€œè¶…èƒ½åŠ›â€
* `Unsafe Rust` å­˜åœ¨æ˜¯å› ä¸ºä»¥ä¸‹å‡ ä¸ªåŸå› 
1. é™æ€åˆ†ææ˜¯ä¿å®ˆçš„ï¼ˆå³å‡ºäºå®‰å…¨è€ƒè™‘ä¼šé”™è¯¯åˆ¤æ–­ä¸€äº›æƒ…å†µä¸ºä¸åˆæ³•ï¼‰ï¼Œè€Œä½¿ç”¨ `Unsafe Rust`ï¼Œå³å‘Šè¯‰ç¼–è¯‘å™¨æˆ‘ä»¬çŸ¥é“è‡ªå·±åœ¨åšä»€ä¹ˆï¼Œå¹¶æ‰¿æ‹…ç›¸åº”é£é™©
2. è®¡ç®—æœºç¡¬ä»¶æœ¬èº«å°±æ˜¯ä¸å®‰å…¨çš„ï¼ŒRust éœ€è¦èƒ½å¤Ÿè¿›è¡Œåº•å±‚çš„ç³»ç»Ÿç¼–ç¨‹ï¼Œå¦‚æœä¸å…è®¸ `Unsafe Rust` é‚£ä¹ˆè¿™äº›å·¥ä½œå°±æ— æ³•å®Œæˆäº†

### Unsafe è¶…èƒ½åŠ›
* å¯ä»¥ä½¿ç”¨ `unsafe` å…³é”®å­—æ¥åˆ‡æ¢åˆ° `Unsafe Rust` æ¨¡å¼ï¼Œå®ƒä¼šåè¾¹è·Ÿç€ä¸€ä¸ªä»£ç å—ï¼Œåœ¨è¿™ä¸ªä»£ç å—é‡Œå†™çš„ä»£ç å°±æ˜¯ `unsafe` ä»£ç 
* `Unsafe Rust` é‡Œå¯æ‰§è¡Œ 4 ä¸ªåŠ¨ä½œï¼ˆè¶…èƒ½åŠ›ï¼‰
1. è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆ
2. è°ƒç”¨ `unsafe` å‡½æ•°æˆ–æ–¹æ³•
3. è®¿é—®æˆ–ä¿®æ”¹å¯å˜çš„é™æ€å˜é‡
4. å®ç° `unsafe trait`

> `unsafe` å¹¶æ²¡æœ‰å…³é—­å€Ÿç”¨æ£€æŸ¥æˆ–åœç”¨å…¶ä»–çš„å®‰å…¨æ£€æŸ¥æªæ–½ï¼Œå¦‚æœä½ åœ¨ `unsafe` é‡Œä½¿ç”¨å¼•ç”¨ï¼Œé‚£ä¹ˆè¿™ä¸ªå¼•ç”¨ä¾ç„¶ä¼šè¢«æ£€æŸ¥ï¼Œ`unsafe` ä»…ä»…æ˜¯è®©ä½ å¯ä»¥è®¿é—®ä¸Šè¿° 4 ä¸ªç‰¹æ€§ï¼Œæ‰€ä»¥å³ä¾¿æ˜¯ `unsafe` ä¸­ä½ ä¾ç„¶ä¼šè·å¾—ä¸€å®šçš„å®‰å…¨æ€§ï¼Œé€šè¿‡æŠŠä¸Šè¾¹ 4 ç§ä¸å®‰å…¨æ“ä½œçº¦æŸåœ¨ `unsafe` ä»£ç å—ä¸­ï¼Œä½ å°±è¦çŸ¥é“ä»»ä½•å†…å­˜å®‰å…¨ç›¸å…³çš„é”™è¯¯å¿…é¡»ç•™åœ¨ `unsafe` å—é‡Œï¼Œå°½å¯èƒ½éš”ç¦» `unsafe` ä»£ç ï¼Œæœ€åå°†å…¶å°è£…åœ¨å®‰å…¨çš„æŠ½è±¡é‡Œï¼Œæä¾›å®‰å…¨çš„ APIã€‚å®é™…ä¸ŠæŸäº›æ ‡å‡†åº“å°±ä½¿ç”¨äº† `unsafe` ä»£ç ï¼Œä½†ä»–ä»¬åœ¨è¿™ä¹‹ä¸Šåˆæä¾›äº†å®‰å…¨çš„æŠ½è±¡æ¥å£ï¼Œå› ä¸ºä½¿ç”¨å®‰å…¨çš„æŠ½è±¡æ˜¯å®‰å…¨çš„ã€‚
{: .prompt-info }


### 1 è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆ
* åœ¨ `Unsafe Rust` é‡Œæœ‰ä¸¤ç§ç±»ä¼¼äºå¼•ç”¨çš„æ–°å‹æŒ‡é’ˆï¼Œå®ƒä»¬å«åŸå§‹æŒ‡é’ˆï¼ˆæˆ–å«è£¸æŒ‡é’ˆè‹±æ–‡æ˜¯ Raw Pointerï¼‰
1. ä¸å¼•ç”¨ç±»ä¼¼ï¼Œå®ƒè¦ä¹ˆæ˜¯å¯å˜çš„ï¼Œè¦ä¹ˆæ˜¯ä¸å¯å˜çš„
2. å¯å˜çš„ï¼Œè¯­æ³•æ˜¯ `*mut T`
3. ä¸å¯å˜çš„ï¼Œè¯­æ³•æ˜¯ `*const T`ï¼Œæ„å‘³ç€æŒ‡é’ˆåœ¨è§£å¼•ç”¨ä¹‹åä¸èƒ½ç›´æ¥å¯¹å…¶è¿›è¡Œèµ‹å€¼

> è¿™é‡Œ `*` ä¸æ˜¯è§£å¼•ç”¨ç¬¦å·ï¼Œå®ƒæ˜¯ç±»å‹åçš„ä¸€éƒ¨åˆ†ï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªæŒ‡é’ˆ
{: .prompt-info }


#### åŸå§‹æŒ‡é’ˆä¸å¼•ç”¨çš„åŒºåˆ«
1. åŸå§‹æŒ‡é’ˆå¯å¿½ç•¥å€Ÿç”¨è§„åˆ™ï¼Œå³å…è®¸é€šè¿‡åŒæ—¶å…·æœ‰ä¸å¯å˜å’Œå¯å˜æŒ‡é’ˆæˆ–å¤šä¸ªæŒ‡å‘åŒä¸€ä½ç½®çš„å¯å˜æŒ‡é’ˆ
2. åŸå§‹æŒ‡é’ˆæ— æ³•ä¿è¯èƒ½æŒ‡å‘åˆç†çš„å†…å­˜ï¼Œè€Œå¼•ç”¨æ€»æ˜¯æŒ‡å‘åˆç†çš„å†…å­˜
3. åŸå§‹æŒ‡é’ˆå…è®¸ä¸º `null`
4. åŸå§‹æŒ‡é’ˆä¸å®ç°ä»»ä½•è‡ªåŠ¨æ¸…ç†

* åœ¨æ”¾å¼ƒè¿™äº›å®‰å…¨çš„ä¿è¯åï¼Œå°±å¯ä»¥æ¢å–æ›´å¥½çš„æ€§èƒ½ä»¥åŠä¸å…¶ä»–è¯­è¨€æˆ–ç¡¬ä»¶æ¥å£çš„èƒ½åŠ›äº†

```rust
fn main() {
    let mut num = 5;

    /*
        åœ¨ unsafe ä»£ç å—ä¹‹å¤–åˆ›å»ºåŸå§‹æŒ‡é’ˆ
        ä½†åªèƒ½åœ¨ unsafe ä»£ç å—ä¸­å¯¹åŸå§‹æŒ‡é’ˆè§£å¼•ç”¨
    */
    // å°†ä¸å¯å˜å¼•ç”¨è½¬ä¸ºä¸å¯å˜åŸå§‹æŒ‡é’ˆï¼Œè¿™æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„åŸå§‹æŒ‡é’ˆ
    let r1 = &num as *const i32;

    // å°†å¯å˜å¼•ç”¨è½¬ä¸ºå¯å˜åŸå§‹æŒ‡é’ˆï¼Œè¿™æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„åŸå§‹æŒ‡é’ˆ
    let r2 = &mut num as *mut i32;

    // å¯¹åŸå§‹æŒ‡é’ˆè§£å¼•ç”¨
    unsafe {
        println!("r1: {}", *r1);
        println!("r2: {}", *r2);   

        // å¯ä»¥ç”¨ r2 ä¿®æ”¹å…¶å€¼ï¼Œè¿™éœ€è¦å¤šåŠ å°å¿ƒ
        *r2 = 3; 
        println!("r2: change to {}", *r2);   
    }

    /*
        åˆ›å»ºä¸€ä¸ªæ— æ³•çŸ¥é“å…¶æœ‰æ•ˆæ€§çš„åŸå§‹æŒ‡é’ˆ
        åŸå§‹æŒ‡é’ˆä¸ä¸€å®šä¸€ç›´æœ‰æ•ˆ

        è¿™ä¸ªå†…å­˜åœ°å€å¯èƒ½æœ‰æ•°æ®ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰æ•°æ®ï¼Œè¿™æ ·ä¾ç„¶å¯ä»¥åˆ›å»ºä¸€ä¸ªåŸå§‹æŒ‡é’ˆ
        address å¯èƒ½æ˜¯æ— æ•ˆçš„
     */
    let address = 0x1245usize;
    let r = address as *const i32;
    // å¯¹åŸå§‹æŒ‡é’ˆè§£å¼•ç”¨
    unsafe {
        println!("r: {}", *r);
    }

}
```

#### ä½¿ç”¨åŸå§‹æŒ‡é’ˆçš„åŸå› 
1. ä¸ C è¯­è¨€è¿›è¡Œæ¥å£äº¤äº’
2. æ„å»ºå€Ÿç”¨æ£€æŸ¥å™¨æ— æ³•ç†è§£çš„å®‰å…¨æŠ½è±¡


### 2 è°ƒç”¨ unsafe å‡½æ•°æˆ–æ–¹æ³•
* `unsafe` å‡½æ•°æˆ–æ–¹æ³•ï¼Œå³åœ¨å®ƒä»¬å‰è¾¹åŠ ä¸Šäº† `unsafe` å…³é”®å­—çš„å‡½æ•°æˆ–æ–¹æ³•
* è°ƒç”¨å®ƒä»¬å‰éœ€è¦æ»¡è¶³ä¸€äº›æ¡ä»¶ï¼ˆä¸»è¦é çœ‹æ–‡æ¡£ï¼‰ï¼Œå› ä¸º Rust æ— æ³•å¯¹è¿™äº›æ¡ä»¶è¿›è¡ŒéªŒè¯
* è°ƒç”¨ `unsafe` å‡½æ•°æˆ–æ–¹æ³•ï¼Œå¿…é¡»åœ¨ `unsafe` å—é‡Œè°ƒç”¨
* `unsafe` å‡½æ•°æˆ–æ–¹æ³•ä¹Ÿå±äº `unsafe` å—

```rust

unsafe fn dangerous() {
    println!("I am dangerous !");
}

fn main() {

    // è°ƒç”¨ Unsafe å‡½æ•°éœ€è¦å† Unsafe å—é‡Œ
    unsafe {
        dangerous();
    }

}
```

#### åˆ›å»º unsafe ä»£ç çš„å®‰å…¨æŠ½è±¡
* å‡½æ•°åŒ…å« `unsafe` ä»£ç å¹¶ä¸æ„å‘³ç€éœ€è¦å°†æ•´ä¸ªå‡½æ•°æ ‡è®°ä¸º `unsafe`
* å°† `unsafe` ä»£ç åŒ…è£¹åœ¨å®‰å…¨å‡½æ•°ä¸­æ˜¯ä¸€ç§å¸¸è§çš„æŠ½è±¡

ä¸‹è¾¹ä»£ç è®©æˆ‘ä»¬çœ‹çœ‹æ ‡å‡†åº“æä¾› `split_at_mut` å‡½æ•°æ˜¯å¦‚ä½•å®ç°çš„

```rust
/*
    ç®€å•å®šä¹‰ split_at_mut çœ‹çœ‹å…¶å®ç°çš„åŸç†
 */
// fn split_at_mut_demo(slice: &mut [i32], mid: usize) 
// -> (&mut [i32], &mut [i32]) {
//     let len = slice.len();

//     assert!(mid <= len);
//     // è¿™é‡ŒæŠ¥é”™ï¼Œå› ä¸ºè¿åäº†å€Ÿç”¨è§„åˆ™, ä½†è¿™é‡Œå…¶å®æ˜¯åˆ‡ç‰‡çš„ä¸¤ä¸ªéƒ¨åˆ†æ²¡æœ‰äº¤é›†ï¼Œå…¶å®æ˜¯å®‰å…¨çš„
//     // ä¿®æ­£éœ€è¦ä½¿ç”¨ unsafe code
//     (&mut slice[..mid], &mut slice[mid..])
// }


/*
    è‡ªå·±å®ç° split_at_mut 
    
    ä½¿ç”¨ unsafe ä»£ç ä¿®æ­£ split_at_mut_demo
    split_at_mut é‡Œä½¿ç”¨äº† unsafe ä»£ç ï¼Œä½†æ˜¯å…¶å‡½æ•°
    æœ¬èº«æ²¡æœ‰æ ‡è®°ä¸º unsafe æ‰€ä»¥ split_at_mut å°±æ˜¯ä¸€ä¸ª
    unsafe å®‰å…¨æŠ½è±¡ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä»å®‰å…¨çš„ä»£ç ä¸­å¯¹å…¶è¿›è¡Œè°ƒç”¨
 */
fn split_at_mut(slice: &mut [i32], mid: usize) 
-> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    assert!(mid <= len);
    /*
        è¿™é‡Œè¿”å›ä¸€ä¸ªåŸå§‹æŒ‡é’ˆï¼Œå®ƒçš„ç±»å‹æ˜¯ *mut i32
        å®ƒæŒ‡å‘è¿™ä¸ªåˆ‡ç‰‡
     */
    let ptr = slice.as_mut_ptr();

    unsafe {
        /*
            from_raw_parts_mut æ¥æ”¶ä¸€ä¸ªåŸå§‹æŒ‡é’ˆå’Œä¸€ä¸ªé•¿åº¦æ¥åˆ›å»ºåˆ‡ç‰‡
            ptr.add(mid) è·å¾—ä»¥ mid ä¸ºåç§»é‡çš„åŸå§‹æŒ‡é’ˆ
         */
        (slice::from_raw_parts_mut(ptr, mid),
        slice::from_raw_parts_mut(ptr.add(mid), len - mid)
        )
    }

}

fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];
    // r æ˜¯ v çš„å®Œæ•´çš„ slice
    let r = &mut v[..];
    /*
        æ ‡å‡†åº“æä¾› split_at_mut å‡½æ•°ï¼Œ
        å°†å‚æ•° index ä¸ºç•Œé™ï¼Œ
        åˆ†éš”æˆä¸¤ä¸ªåˆ‡ç‰‡
        split_at_mut å®é™…æ˜¯ä½¿ç”¨äº†ä¸å®‰å…¨çš„ä»£ç 
     */
    let (a, b) = split_at_mut(r, 3);
    //let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]); 
}
```

* è¿™æ ·å¯èƒ½ crash å› ä¸ºæ— æ³•ä¿è¯æ‹¥æœ‰ 10000 å…ƒç´ çš„åˆ‡ç‰‡æ˜¯æœ‰æ•ˆçš„

```rust
fn main() {
    println!("test_address");
    let address = 0x12345usize;
    let r = address as *mut i32;
    // è¿™æ ·å¯èƒ½ crash å› ä¸ºæ— æ³•ä¿è¯æ‹¥æœ‰ 10000 å…ƒç´ çš„åˆ‡ç‰‡æ˜¯æœ‰æ•ˆçš„
    let slice: &[i32] = unsafe {
        slice::from_raw_parts_mut(r, 10000)
    }; 
}
```

### ä½¿ç”¨ extern å‡½æ•°è°ƒç”¨å¤–éƒ¨ä»£ç 
* `extern` å…³é”®å­—å¯ä»¥ç®€åŒ–åˆ›å»ºå’Œä½¿ç”¨å¤–éƒ¨å‡½æ•°æ¥å£ï¼ˆFFIï¼‰çš„è¿‡ç¨‹
* å¤–éƒ¨å‡½æ•°æ¥å£ï¼ˆFFIï¼ŒForeign Function Interfaceï¼‰ï¼Œå®ƒå…è®¸ä¸€ç§ç¼–ç¨‹è¯­è¨€å®šä¹‰å‡½æ•°ï¼Œå¹¶è®©å…¶ä»–çš„ç¼–ç¨‹è¯­è¨€èƒ½è°ƒç”¨è¿™äº›å‡½æ•°

> ä»»ä½•åœ¨ `extern` å—é‡Œå£°æ˜çš„å‡½æ•°éƒ½æ˜¯ä¸å®‰å…¨çš„ï¼Œå› ä¸ºå…¶ä»–è¯­è¨€å¹¶ä¸ä¼šéµå®ˆ Rust çš„è§„åˆ™ï¼Œè€Œ Rust åˆæ— æ³•å¯¹ä»–ä»¬è¿›è¡Œæ£€æŸ¥
{: .prompt-info }

æ‰€ä»¥åœ¨è°ƒç”¨å¤–éƒ¨å‡½æ•°æ—¶çš„å®‰å…¨é—®é¢˜è½åœ¨äº†å¼€å‘è€…èº«ä¸Š


```rust
/*
    extern "C" å—å†…çš„å‡½æ•°ç­¾åå°±æ˜¯æˆ‘ä»¬æƒ³è°ƒç”¨çš„å¤–éƒ¨å‡½æ•°çš„ç­¾å
    è€Œ "C" æŒ‡æ˜äº†å¤–éƒ¨å‡½æ•°ä½¿ç”¨çš„æ˜¯åº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ¥å£ï¼ˆABIï¼‰ï¼Œ
    ABI æ˜¯ç”¨äºå®šä¹‰åœ¨æ±‡ç¼–å±‚é¢çš„è°ƒç”¨æ–¹å¼çš„
 */ 
extern "C" {
    fn abs(input:i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```

* ABI æ˜¯ç”¨äºå®šä¹‰åœ¨æ±‡ç¼–å±‚é¢çš„è°ƒç”¨æ–¹å¼çš„
* "C" ABI æ˜¯æœ€å¸¸è§çš„ï¼Œå®ƒéµå¾ª C è¯­è¨€çš„ ABI

### ä»å…¶ä»–è¯­è¨€æ¥è°ƒç”¨ Rust å‡½æ•°
* å¯ä»¥ä½¿ç”¨ `extern` å…³é”®å­—æ¥åˆ›å»ºæ¥å£ï¼Œå…¶ä»–è¯­è¨€é€šè¿‡å®ƒä»¬å¯ä»¥è°ƒç”¨ Rust å‡½æ•°
* åœ¨ `fn` å‰è¾¹æ·»åŠ  `extern` å…³é”®å­—ï¼Œå¹¶æŒ‡å®šå¯¹åº”çš„ ABIã€‚å¹¶ä¸”è¿˜éœ€è¦æ·»åŠ  `#[no_mangle]` æ³¨è§£ï¼Œé¿å… Rust åœ¨ç¼–è¯‘æ—¶æ”¹å˜å®ƒçš„åç§°
1. `mangle` å®é™…å¯¹åº”ç¼–è¯‘çš„ä¸€ä¸ªé˜¶æ®µï¼Œåœ¨è¿™ä¸ªé˜¶æ®µç¼–è¯‘å™¨ä¼šä¿®æ”¹å‡½æ•°çš„åç§°ä»è€Œè®©å…¶åŒ…å«æ›´å¤šå¯ç”¨äºåç»­ç¼–è¯‘çš„ä¿¡æ¯ï¼Œè¿™äº›æ”¹å˜åçš„åç§°é€šå¸¸æ˜¯éš¾ä»¥é˜…è¯»çš„

```rust
// è¿™ä¸ªå‡½æ•°åœ¨ç¼–è¯‘é“¾æ¥åå°±å¯ä»¥è¢« C è¯­è¨€è®¿é—®äº†
// è¿™ç±»çš„ extern åŠŸèƒ½ä¸éœ€è¦ä½¿ç”¨ unsafe

#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just call a rust function from C!");
}
```

### 3. è®¿é—®æˆ–ä¿®æ”¹ä¸€ä¸ªå¯å˜çš„é™æ€å˜é‡
* Rust æ”¯æŒå…¨å±€å˜é‡ï¼Œä½†å› ä¸ºæ‰€æœ‰æƒæœºåˆ¶å¯èƒ½äº§ç”ŸæŸäº›é—®é¢˜ï¼Œä¾‹å¦‚æ•°æ®ç«äº‰
* åœ¨ Rust ä¸­å…¨å±€å˜é‡å«é™æ€ï¼ˆstaticï¼‰å˜é‡


```rust
/*
    å‘½åè§„èŒƒå¤§å†™ï¼Œå£°æ˜æ—¶éœ€è¦æ ‡è¯†ç±»å‹
    é™æ€å˜é‡åªèƒ½å­˜å‚¨æ‹¥æœ‰ 'static è¿™ä¸ªç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
    è¿™å°±æ„å‘³ç€ Rust å¯ä»¥è‡ªå·±æ¨æ–­å‡ºå…¶ç”Ÿå‘½å‘¨æœŸ
    æ‰€ä»¥å°±æ— éœ€æ‰‹åŠ¨æ ‡æ³¨äº†

 */
static HELLO_WORLD: &str = "Hello, world!";
fn main() {
    println!("name is {}", HELLO_WORLD);
}
```

#### é™æ€å˜é‡
* é™æ€å˜é‡ä¸å¸¸é‡ç±»ä¼¼
* å‘½åè§„èŒƒæ˜¯å¤§å†™çš„ SCREAMING_SNAKE_CASE
* å£°æ˜æ—¶å€™å¿…é¡»æ ‡æ³¨ç±»å‹
* é™æ€å˜é‡åªèƒ½å­˜å‚¨ `'static` ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨ï¼Œæ— éœ€æ˜¾ç¤ºæ ‡æ³¨ï¼Œå› ä¸ºå¯ä»¥æ¨æ–­å‡ºæ¥
* è®¿é—®ä¸å¯å˜çš„é™æ€å˜é‡æ˜¯å®‰å…¨çš„

#### å¸¸é‡å’Œä¸å¯å˜é™æ€å˜é‡çš„åŒºåˆ«
* é™æ€å˜é‡ï¼šæœ‰å›ºå®šçš„å†…å­˜åœ°å€ï¼Œä½¿ç”¨å®ƒçš„å€¼æ€»ä¼šè®¿é—®åŒæ ·çš„æ•°æ®
* å¸¸é‡ï¼šå…è®¸ä½¿ç”¨å®ƒä»¬çš„æ—¶å€™å¯¹æ•°æ®è¿›è¡Œå¤åˆ¶
* é™æ€å˜é‡ï¼šæ˜¯å¯ä»¥æ”¹å˜çš„ï¼Œ`è®¿é—®`å’Œ`ä¿®æ”¹`å¯å˜çš„é™æ€å˜é‡`æ˜¯ä¸å®‰å…¨ï¼ˆunsafeï¼‰çš„æ“ä½œ`

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    // è®¿é—®å’Œä¿®æ”¹å¯å˜çš„é™æ€å˜é‡æ˜¯ä¸å®‰å…¨ï¼ˆunsafeï¼‰çš„æ“ä½œ
    // æ‰€ä»¥è¿™é‡Œæ”¾åˆ° unsafe å—é‡Œè¿›è¡Œæ“ä½œ
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);
    
    // è¿™é‡Œæ˜¯å•çº¿ç¨‹ï¼Œä½†å¤šçº¿ç¨‹å…¶å®æ— æ³•ä¿è¯æ•°æ®ç«äº‰ä¸å‘ç”Ÿ
    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```

### 4. å®ç° unsafe trait
* å½“æŸä¸ª `trait` ä¸­å­˜åœ¨è‡³å°‘ä¸€ä¸ªæ–¹æ³•æ‹¥æœ‰ç¼–è¯‘å™¨æ— æ³•æ ¡éªŒçš„ä¸å®‰å…¨å› ç´ æ—¶ï¼Œå°±ç§°è¿™ä¸ª `trait` æ˜¯ä¸å®‰å…¨çš„
* å£°æ˜ä¸å®‰å…¨çš„ traitï¼šå³åœ¨ `trait` å‰åŠ  `unsafe` å…³é”®å­—
1. è¯¥ `trait` åªèƒ½åœ¨ `unsafe` ä»£ç å—ä¸­å®ç°

```rust
unsafe trait Foo {
    // methods go here
}

// åœ¨ unsafe ä»£ç å—ä¸­å®ç°
unsafe impl Foo for i32 {
    // method implementations go here
}
```

### ä½•æ—¶ä½¿ç”¨ `unsafe` ä»£ç 
* ç¼–è¯‘å™¨æ— æ³•ä¿è¯å†…å­˜å®‰å…¨ï¼Œè®©å¼€å‘è€…ä¿è¯ `unsafe` ä»£ç æ­£ç¡®å¹¶ä¸æ˜¯ä¸€ä¸ªç®€å•æ´»å„¿
* ä½†åˆå……è¶³ç†ç”±ä½¿ç”¨ `unsafe` ä»£ç æ—¶ï¼Œå°±å¯ä»¥ä½¿ç”¨
* é€šè¿‡æ˜¾ç¤ºæ ‡è®°çš„ `unsafe`ï¼Œå¯ä»¥åœ¨å‡ºç°é—®é¢˜æ—¶è½»æ¾å®šä½


## é«˜çº§ Trait

### åœ¨ `trait` çš„å®šä¹‰ä¸­ä½¿ç”¨å…³è”ç±»å‹æ¥æŒ‡å®šå ä½ç±»å‹
* å…³è”ç±»å‹ï¼ˆassociated typeï¼‰æ˜¯ `trait` ä¸­ç±»å‹çš„å ä½ç¬¦ï¼Œå®ƒå¯ä»¥ç”¨åœ¨ `trait` çš„æ–¹æ³•ç­¾åä¸­
1. å³å¯ä»¥å®šä¹‰å‡ºåŒ…å«æŸäº›ç±»å‹çš„ `trait`ï¼Œè€Œåœ¨å®ç°å‰æ— éœ€çŸ¥é“è¿™äº›ç±»å‹å…·ä½“æ˜¯ä»€ä¹ˆ
2. swift ä¹Ÿæœ‰è¿™ä¸ªç‰¹æ€§ 

* æ ‡å‡†åº“çš„ Iterator å°±ä½¿ç”¨äº† associated type
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

### å…³è”ç±»å‹ä¸æ³›å‹çš„åŒºåˆ«
* æ³›å‹
1. æ¯æ¬¡å®ç° `trait` æ—¶å¿…é¡»æ ‡æ³¨å…·ä½“çš„ç±»å‹
2. å¯ä»¥ä¸ºä¸€ä¸ªç±»å‹å¤šæ¬¡å®ç°æŸä¸ª `trait`ï¼ˆå³ä½¿ç”¨ä¸åŒçš„æ³›å‹å‚æ•°ï¼‰

```rust
pub trait Iterator2<T> {
    fn next(&mut self) -> Option<T>;
}

struct Counter {

}

//å¤šæ¬¡å®ç°æŸä¸ª Iterator2 trait for String
impl Iterator2<String> for Counter {
    fn next(&mut self) -> Option<String> {
        None
    }
}

//å¤šæ¬¡å®ç°æŸä¸ª Iterator2 trait for u32
impl Iterator2<u32> for Counter {
    fn next(&mut self) -> Option<u32> {
        None
    }
}
```

* å…³è”ç±»å‹
1. åœ¨ä½¿ç”¨ `trait` æ—¶ï¼Œæ— éœ€æ ‡æ³¨ç±»å‹ï¼Œä½†éœ€è¦åœ¨é‡Œè¾¹æŒ‡æ˜å…³è”çš„ç±»å‹
2. æ— æ³•ä¸ºå•ä¸ªç±»å‹å¤šæ¬¡å®ç°æŸä¸ª `trait`


```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter {

}

impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        None
    }
}
```

> è¿™ä¸ª `Iterator trait` åªèƒ½ä¸º `Counter` ç±»å‹å®ç°ä¸€æ¬¡ï¼Œå¤šæ¬¡ä¼šæŠ¥é”™
{: .prompt-info }


### é»˜è®¤æ³›å‹å‚æ•°å’Œè¿ç®—ç¬¦é‡è½½
* å¯ä»¥åœ¨ä½¿ç”¨æ³›å‹å‚æ•°æ—¶ä¸ºæ³›å‹æŒ‡å®šä¸€ä¸ªé»˜è®¤çš„å…·ä½“ç±»å‹
* è¯­æ³•ï¼š`<PlaceholderType=ConcreteType>`ï¼ŒConcreteType å°±æ˜¯é»˜è®¤çš„ç±»å‹
* è¿™ç§æŠ€æœ¯å¸¸ç”¨äºè¿ç®—ç¬¦é‡è½½ï¼ˆoperator overloadingï¼‰

> è™½ç„¶ Rust ä¸å…è®¸åˆ›å»ºè‡ªå·±çš„è¿ç®—ç¬¦ä»¥åŠé‡è½½ä»»æ„çš„è¿ç®—ç¬¦ã€‚ä½†å¯ä»¥é€šè¿‡å®ç° `std::ops` ä¸­åˆ—å‡ºçš„é‚£äº› trait æ¥é‡è½½ä¸€éƒ¨åˆ†ç›¸åº”çš„è¿ç®—ç¬¦
{: .prompt-info }


è¿™é‡Œé‡è½½äº† `+` è¿ç®—ç¬¦
```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, rhs: Self) -> Self::Output {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {

    assert_eq!(Point { x: 1, y: 0} + Point { x: 2, y: 3},
               Point {x: 3,y: 3});
    println!("point add");
}
```

* `pub trait Add<Rhs = Self>`ï¼ŒAdd è¿™é‡Œå°±ä½¿ç”¨äº†é»˜è®¤çš„æ³›å‹å‚æ•°ç±»å‹ï¼Œå³å¦‚æœåœ¨ä½¿ç”¨ trait æ—¶æ²¡æœ‰æŒ‡å®šé»˜è®¤æ³›å‹å‚æ•°ç±»å‹åˆ™ä½¿ç”¨ Self ä½œä¸ºé»˜è®¤ç±»å‹ï¼Œ
æ‰€ä»¥ä¸Šè¾¹ä»£ç ä¸­ Self å°±æ˜¯ Point


#### è‡ªå·±æŒ‡å®šé»˜è®¤æ³›å‹å‚æ•°ç±»å‹

* ä¸º Millimeters å®ç° Add traitï¼Œè®©æ¯«ç±³ä¸ç±³å¯ä»¥ç›¸åŠ 

```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

// è¿™é‡ŒæŒ‡å®šé»˜è®¤çš„æ³›å‹å‚æ•°ä¸º Meters
impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, rhs: Meters) -> Self::Output {
        Millimeters(self.0 + (rhs.0 * 1000)) 
    }
}
```

#### é»˜è®¤æ³›å‹å‚æ•°çš„åº”ç”¨åœºæ™¯
* æ‰©å±•ä¸€ä¸ªç±»å‹è€Œä¸ç ´åç°æœ‰çš„ä»£ç 
* å…è®¸åœ¨å¤§éƒ¨åˆ†ç”¨æˆ·éƒ½ä¸éœ€è¦çš„ç‰¹å®šåœºæ™¯ä¸‹è¿›è¡Œè‡ªå®šä¹‰
1. ä¸Šè¾¹ Millimeters å’Œ Meters çš„ä¾‹å­å°±å±äºè‡ªå®šä¹‰


### å®Œå…¨é™å®šè¯­æ³•ï¼ˆFully Qualified Syntaxï¼‰å¦‚ä½•è°ƒç”¨åŒåæ–¹æ³•

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("Human's fly");
    }
}

fn main() {
    let person = Human;
    person.fly(); // è¿™æ ·æ˜¯è°ƒç”¨ Human æœ¬èº«çš„ fly æ–¹æ³•ï¼Œå³æ‰“å° Human's fly

    // è°ƒç”¨ Human çš„ Pilot å®ç°
    Pilot::fly(&person);
    
    Wizard::fly(&person);
}
```

* ä¸Šè¾¹ä»£ç æ¯”è¾ƒç®€å•è°ƒç”¨æ²¡æœ‰é—®é¢˜

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn test_dog() {
    println!("A baby dog is called a {}", Dog::baby_name());

    // è¿™æ ·å°±ä¼šæŠ¥é”™ï¼Œå› ä¸ºæ— æ³•çŸ¥é“ä½¿ç”¨å“ªä¸ªç±»å‹çš„ Animal å®ç°
    println!("A baby dog is called a {}", Animal::baby_name());
}
```

* ä¸Šè¾¹ä»£ç è°ƒç”¨ `Animal::baby_name()` å°±ä¼šæŠ¥é”™ï¼Œå› ä¸ºæ— æ³•çŸ¥é“ä½¿ç”¨å“ªä¸ªç±»å‹çš„ `Animal` å®ç°
* è¿™æ—¶å¯ä»¥ä½¿ç”¨å®Œå…¨é™å®šè¯­æ³•äº†

#### å®Œå…¨é™å®šè¯­æ³•
* æ ¼å¼ï¼š`<Type as Trait>::function(receiver_if_method, netx_arg, ...);`
1. `receiver_if_method` æ˜¯æ¥æ”¶è€…
2. `netx_arg` æ˜¯å‡½æ•°å‚æ•°

* è¿™ç§è¯­æ³•å¯ä»¥åœ¨ä»»ä½•è°ƒç”¨å‡½æ•°æˆ–æ–¹æ³•çš„åœ°æ–¹ä½¿ç”¨
* å¹¶ä¸”å®ƒå…è®¸å¿½ç•¥é‚£äº›ä»å…¶ä»–ä¸Šä¸‹æ–‡èƒ½æ¨å¯¼å‡ºæ¥çš„éƒ¨åˆ†

> åªæœ‰å½“ Rust æ— æ³•åŒºåˆ†ä½ æœŸæœ›è°ƒç”¨å“ªä¸ªå…·ä½“å®ç°çš„æ—¶å€™ï¼Œæ‰éœ€è¦ä½¿ç”¨è¿™ç§è¯­æ³•ã€‚å› ä¸ºè¿™ç§è¯­æ³•å†™èµ·æ¥æ¯”è¾ƒéº»çƒ¦ ğŸ˜…
{: .prompt-info }


* æ”¹æˆ `<Dog as Animal>::baby_name()` å°±å¯ä»¥äº†

```rust
println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
```

### ä½¿ç”¨ `supertrait` æ¥è¦æ±‚ `trait` é™„å¸¦å…¶ä»– `trait` çš„åŠŸèƒ½
* å°±æ˜¯ä¸€ä¸ª `trait` ç»§æ‰¿å¦å¤–ä¸€ä¸ª `trait`
* æœ‰æ—¶éœ€è¦åœ¨ä¸€ä¸ª `trait` ä¸­ä½¿ç”¨å…¶ä»– `trait` çš„åŠŸèƒ½
1. å³éœ€è¦é‚£ä¸ªé—´æ¥è¢«ä¾èµ–çš„ `trait` ä¹Ÿè¢«å®ç°

> é‚£ä¸ªè¢«é—´æ¥ä¾èµ–çš„ `trait` å°±æ˜¯å½“å‰ `trait` çš„ `supertrait`
{: .prompt-info }

```rust
use std::fmt;

// ç±»ä¼¼äºç»§æ‰¿ï¼Œå³ OutlinePrint ä¾èµ–äº fmt:: Display
trait OutlinePrint: fmt:: Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

struct Point {
    x: i32,
    y: i32,
}

// å› ä¸º OutlinePrint æœ‰é»˜è®¤å®ç°ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬åªå®ç° fmt::Display å°±å¯ä»¥äº†
impl fmt::Display for Point  {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```

### ä½¿ç”¨ `newtype` æ¨¡å¼åœ¨å¤–éƒ¨ç±»å‹ä¸Šå®ç°å¤–éƒ¨ trait
* å­¤å„¿è§„åˆ™ï¼šåªæœ‰å½“ trait æˆ–ç±»å‹å®šä¹‰åœ¨æœ¬åœ°çš„åŒ…å†…æ—¶ï¼Œæ‰èƒ½ä¸ºè¯¥ç±»å‹å®ç°è¿™ä¸ª trait
* ä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡ `newtype` æ¨¡å¼æ¥ç»•è¿‡å­¤å„¿è§„åˆ™
1. å³åˆ©ç”¨ tuple structï¼ˆå…ƒç»„ç»“æ„ä½“ï¼‰åˆ›å»ºä¸€ä¸ªæ–°çš„ç±»å‹


```rust
use std::fmt;
/*
    æˆ‘ä»¬æƒ³ä¸º Vec å®ç° Display è¿™ä¸ª trait
    è€Œ Vec å’Œ Display éƒ½å®šä¹‰åœ¨å¤–éƒ¨çš„åŒ…ä¸­ï¼Œ
    æ‰€ä»¥æˆ‘ä»¬æ— æ³•ç›´æ¥ä¸º Vec å®ç° Display è¿™ä¸ª trait

    é‚£ä¹ˆæ€ä¹ˆåšå‘¢ï¼Ÿ
    æˆ‘ä»¬å¯ä»¥æŠŠ Vec åŒ…è£¹åœ¨ struct Wrapper ä¸­
 */
// åŒ…è£¹ Vec ä»¥ä¾¿å®ç° Display trait
struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        /*
            å› ä¸º Wrapper æ˜¯ä¸€ä¸ª tuple struct å¯ä»¥é€šè¿‡ç´¢å¼•å°† Vec å–å‡º
         */
        write!(f, "[{}]", self.0.join(", "))
    }
}
```

## é«˜çº§ç±»å‹

### 1 ä½¿ç”¨ `newtype` æ¨¡å¼å®ç°ç±»å‹å®‰å…¨å’ŒæŠ½è±¡
* `newtype` æ¨¡å¼çš„ä½œç”¨ï¼š
1. å¯ç”¨äºé™æ€çš„ä¿è¯å„ç§å€¼ä¹‹é—´ä¸ä¼šæ··æ·†å¹¶è¡¨æ˜å€¼çš„å•ä½
2. ä¸ºç±»å‹çš„æŸäº›ç»†èŠ‚æä¾›æŠ½è±¡èƒ½åŠ›
3. å¯é€šè¿‡è½»é‡çº§çš„å°è£…æ¥éšè—å†…éƒ¨å®ç°ç»†èŠ‚

### 2 ä½¿ç”¨ç±»å‹åˆ«åæ¥åˆ›å»ºç±»å‹åŒä¹‰è¯
* Rust æä¾›äº†ç±»å‹åˆ«åçš„åŠŸèƒ½
1. å¯ä»¥ä¸ºç°æœ‰ç±»å‹ç”Ÿäº§å¦å¤–çš„åç§°ï¼ˆåŒä¹‰è¯ï¼‰
2. è¿™ä¸ªç±»å‹çš„åˆ«åå¹¶ä¸æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ç±»å‹

* ä½¿ç”¨ `type` å…³é”®å­—åˆ›å»ºç±»å‹åˆ«å
* åˆ«åçš„ä¸»è¦ç”¨é€”å°±æ˜¯å‡å°‘ä»£ç çš„å­—ç¬¦é‡å¤

```rust
use std::fmt;

// ç±»å‹åˆ«å 1
type Kilometers = i32;


// ç±»å‹åˆ«å 2
type Thunk = Box<dyn Fn() + Send + 'static>;

fn take_long_type(f: Thunk) {

}

fn return_long_type() -> Thunk {
    Box::new(|| println!("hi"))
}

// ç±»å‹åˆ«å 3

// ç”±äºè¿™ä¸ªå£°æ˜åœ¨ use std::io::Error ä¸­æ‰€ä»¥è¿™é‡Œéœ€è¦æ³¨é‡Š
//type Result<T> = Result<T, std::io::Error>;

// å¯ä»¥å†åˆ«åä¸€æ¬¡ï¼Œä»¥ä¾¿ç›´æ¥ä½¿ç”¨ Result<T>
type Result<T> = std::io::Result<T>;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;

    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;

}

fn main() {
    let x: i32 = 5;
    let y: Kilometers = 5;
    println!("x + y = {}", x + y);

    //-----------
    let f: Thunk = Box::new(|| println!("hi"));
}
```

### 3 Never ç±»å‹
* æœ‰ä¸€ä¸ªåä¸º `!` çš„ç‰¹æ®Šç±»å‹ï¼Œè¡¨ç¤ºå‡½æ•°æ°¸è¿œä¸ä¼šè¿”å›å€¼
1. å®ƒæ²¡æœ‰ä»»ä½•å€¼ï¼Œè¡Œè¯ç§°ä¸ºç©ºç±»å‹ï¼ˆempty typeï¼‰

* æˆ‘ä»¬å€¾å‘äºå«å®ƒ `Never` ç±»å‹ï¼Œå› ä¸ºå®ƒåœ¨ä¸è¿”å›å€¼çš„å‡½æ•°ä¸­å……å½“è¿”å›ç±»å‹
* ä¸è¿”å›å€¼çš„å‡½æ•°ä¹Ÿè¢«ç§°ä½œå«å‘æ•£å‡½æ•°ï¼ˆdiverging functionï¼‰

* `Never` ç±»å‹å¯å¼ºåˆ¶è¢«è½¬æ¢ä¸ºå…¶ä»–ç±»å‹è¿›è¡Œè¿”å›ï¼Œä¾‹å¦‚ä¸‹è¾¹ä»£ç çš„ `continue`

```rust
// è¿™ä¸ªå‡½æ•°è¡¨ç¤ºè¿”å› Never ç±»å‹
// è¿™é‡ŒæŠ¥é”™ï¼Œä»€ä¹ˆä¸å†™è¿”å›çš„æ˜¯ `()`

// mismatched types
// expected type `!`
// found unit type `()`
fn bar() -> ! {

}

//------- ä¾‹å­ 1
fn main() {
    let guess = "";

    loop {
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,    
            // è¿™é‡Œ continue å°±æ˜¯ Never ç±»å‹ï¼Œè€Œ Never ç±»å‹æ— æ³•äº§ç”Ÿä¸€ä¸ªå¯ä¾›è¿”å›çš„å€¼ï¼Œ
            // æ‰€ä»¥è¿™ä¸ª Err åˆ†æ”¯çš„ç±»å‹å°±é‡‡ç”¨äº†ç¬¬ä¸€ä¸ªåˆ†æ”¯çš„ç±»å‹      
            Err(_) => continue, 
        };
    };

}
```

* Never çš„è¡¨è¾¾å¼å¯ä»¥è¢«å¼ºåˆ¶è½¬æˆå…¶ä»–çš„ä»»æ„ç±»å‹

```rust
// ä¾‹å­ 2 æ­¤ä»£ç æŠ¥é”™ï¼Œåªç”¨äºç†è§£ Never
impl <T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            // è¿™ä¸ªåˆ†æ”¯è¿”å› T ç±»å‹
            Some(val) => val,
            /*
                è€Œ panic! çš„è¿”å›ç±»å‹å°±æ˜¯ Never
                panic æ—¶ä¼šç»ˆæ­¢ç¨‹åºï¼Œä¸ä¼šè¿”å›ä»»ä½•å€¼
                æ‰€ä»¥ None æ—¶ï¼Œä¸ä¼šè¿”å›å€¼
                æ‰€ä»¥ unwrap çš„ä»£ç å°±æ˜¯åˆç†çš„
             */
            None => panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}

// ä¾‹å­ 3
    loop {
        /*
            è¿™ä¸ªå¾ªç¯æ°¸è¿œä¸ä¼šç»“æŸ
            å®ƒçš„è¿”å›ç±»å‹å°±æ˜¯ !
            å½“ç„¶å¯ä»¥ä½¿ç”¨ break æŒ‡ä»¤ç»ˆæ­¢å¾ªç¯
         */
        print!("and ever ");
    }
```

### åŠ¨æ€å¤§å°çš„ç±»å‹
* Rust éœ€è¦åœ¨ç¼–è¯‘æ—¶ç¡®å®šä¸ºä¸€ä¸ªç‰¹å®šç±»å‹çš„å€¼åˆ†é…å¤šå°‘ç©ºé—´
* åŠ¨æ€å¤§å°ç±»å‹ï¼ˆDynamically Sized Typesï¼ŒDSTï¼‰çš„æ¦‚å¿µ
1. å®ƒå¯ä»¥ä½¿æˆ‘ä»¬åœ¨ç¼–å†™ä»£ç æ—¶ä½¿ç”¨åªæœ‰åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šå¤§å°çš„å€¼


> `str` å°±æ˜¯åŠ¨æ€å¤§å°çš„ç±»å‹ï¼ˆæ³¨æ„`ä¸æ˜¯ &str`ï¼‰ï¼šåªæœ‰è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šå­—ç¬¦ä¸²çš„é•¿åº¦
{: .prompt-info }


* ä¸‹åˆ—ä»£ç æ— æ³•æ­£å¸¸å·¥ä½œï¼Œå› ä¸º Rust æ— æ³•åœ¨ç¼–è¯‘æ—¶çŸ¥æ™“å…¶å å¤šå°‘å†…å­˜
1. è€ŒåŒä¸€ç±»å‹æ‰€æœ‰çš„å€¼å¿…é¡»ä½¿ç”¨ç­‰é‡çš„å€¼

```rust
let s1: str = "Hello there!";
let s2: str = "How's it going?";
```

* å¯ä»¥ä½¿ç”¨ `&strï¼ˆå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼‰`è§£å†³ä¸Šè¾¹çš„ä»£ç 
1. `&str` é‡Œå­˜å‚¨çš„æ˜¯ `str çš„åœ°å€`ä»¥åŠ `str çš„é•¿åº¦`
2. å®ƒå°±å­˜è¿™ä¿©æ‰€ä»¥å®ƒçš„å†…å­˜å¤§å°è‚¯å®šæ˜¯å›ºå®šçš„

### Rust ä½¿ç”¨åŠ¨æ€å¤§å°ç±»å‹çš„é€šç”¨æ–¹å¼
* å®ƒä»¬æ€»ä¼šé™„å¸¦ä¸€äº›é¢å¤–çš„å…ƒæ•°æ®æ¥å­˜å‚¨åŠ¨æ€ä¿¡æ¯çš„å¤§å°
1. ä½¿ç”¨åŠ¨æ€å¤§å°ç±»å‹çš„æ—¶æ€»ä¼šæŠŠå®ƒçš„å€¼æ”¾åœ¨æŸç§æŒ‡é’ˆåè¾¹ï¼Œå°±åƒ `str ä¸ &str`

### å¦å¤–ä¸€ç§åŠ¨æ€å¤§å°çš„ç±»å‹ï¼šå³ `Trait`

> å…¶å®æ¯ä¸€ä¸ª `Trait` éƒ½æ˜¯ä¸€ä¸ªåŠ¨æ€å¤§å°çš„ç±»å‹ï¼Œå¯ä»¥é€šè¿‡åç§°å¯¹å…¶è¿›è¡Œå¼•ç”¨
{: .prompt-info }

* ä¸ºäº†å°† `trait` ç”¨ä½œ `trait` å¯¹è±¡ï¼Œå¿…é¡»å°†å®ƒæ”¾ç½®åœ¨æŸç§æŒ‡é’ˆä¹‹å
1. ä¾‹å¦‚ `dyn Trait` æˆ– `Box<dyn Trait>` (`Rc<dyn Trait>`) ä¹‹å

### Sized Trait
* ä¸ºäº†å¤„ç†åŠ¨æ€å¤§å°çš„ç±»å‹ï¼ŒRust æä¾›äº†ä¸€ä¸ª `Sized Trait` æ¥ç¡®å®šä¸€ä¸ªç±»å‹çš„å¤§å°åœ¨ç¼–è¯‘æ—¶æ˜¯å¦å·²çŸ¥
1. åœ¨ç¼–è¯‘æ—¶å¯ä»¥è®¡ç®—å‡ºå¤§å°çš„ç±»å‹ä¼šè‡ªåŠ¨å®ç°è¿™ä¸€ trait
2. Rust è¿˜ä¼šä¸ºæ¯ä¸€ä¸ªæ³›å‹å‡½æ•°éšå¼çš„æ·»åŠ  `Sized çº¦æŸ`


```rust
fn generic<T>(t: T) {

}
// ä¸Šè¾¹ä¼šè¢«éšå¼è½¬åŒ–ä¸ºä¸‹è¾¹è¿™æ ·
fn generic<T: Sized>(t: T) {

}
```

* é»˜è®¤æƒ…å†µä¸‹ï¼Œæ³›å‹å‡½æ•°åªèƒ½è¢«ç”¨äºç¼–è¯‘æ—¶å·²ç»çŸ¥é“å¤§å°çš„ç±»å‹ï¼Œå¯ä»¥é€šè¿‡ç‰¹æ®Šè¯­æ³•è§£é™¤è¿™ä¸€é™åˆ¶
1. `?Sized Trait` çº¦æŸ
2. `?Sized` è¡¨è¾¾äº†ä¸ç¡®å®šæ€§ï¼Œå°±è¡¨ç¤º `T` å¯èƒ½æ˜¯ `Sized` çš„ä¹Ÿå¯èƒ½ä¸æ˜¯ `Sized` çš„

> é™åˆ¶ï¼š`?Sized` åªèƒ½è¢«ç”¨åœ¨ `Sized` çš„ä¸Šè¾¹ï¼Œä¸èƒ½ç”¨äºå…¶ä»–çš„ `Trait`
{: .prompt-info }


```rust
// è¿™æ—¶ T ä¼šå˜æˆ &Tï¼Œå› ä¸º T å¯èƒ½ä¸æ˜¯ Sized çš„ï¼Œè¿™æ—¶å°±éœ€è¦æ”¾åœ¨æŸç§æŒ‡é’ˆåè¾¹
fn generic<T: ?Sized>(t: &T) {

}
```

## é«˜çº§å‡½æ•°å’Œé—­åŒ…

### å‡½æ•°æŒ‡é’ˆ
* å‡½æ•°å¯ä»¥ä¼ é€’ç»™å…¶ä»–å‡½æ•° ï¼ˆé—­åŒ…ä¹Ÿå¯ä»¥ä¼ é€’ç»™å‡½æ•°ï¼Œä¹‹å‰è®²è¿‡ï¼‰
* åœ¨ä¼ é€’çš„è¿‡ç¨‹ä¸­å‡½æ•°å°±ä¼šè¢«å¼ºåˆ¶è½¬æ¢æˆ `fn` è¿™ä¸ªç±»å‹
* `fn` å°±æ˜¯æ‰€è°“çš„å‡½æ•°æŒ‡é’ˆï¼ˆfunction pointerï¼‰

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

/*
    å‚æ•°æ—¶ fn å³å‡½æ•°æŒ‡é’ˆ
    è¿™ä¸ªå‡½æ•°æŒ‡é’ˆè¦æ±‚å‚æ•°æ˜¯ i32ï¼Œè¿”å›å€¼ä¹Ÿæ˜¯ i32
 */
fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn test_fn() {
    let answer = do_twice(add_one, 5);
    println!("The answer is: {}", answer);
}
```

### å‡½æ•°æŒ‡é’ˆä¸é—­åŒ…çš„åŒºåˆ«
#### é—­åŒ…
1. é—­åŒ…å°±æ˜¯å®ç°äº† 3 ç§`é—­åŒ… Trait`

#### `fn` å‡½æ•°æŒ‡é’ˆ
1. å®ƒæ˜¯ä¸€ä¸ªç±»å‹ï¼Œè€Œä¸æ˜¯ä¸€ä¸ª `Trait`
2. æˆ‘ä»¬å¯ä»¥ç›´æ¥æŒ‡å®š `fn` ä¸ºå‚æ•°ç±»å‹ï¼Œè€Œä¸ç”¨å£°æ˜ä¸€ä¸ªä»¥ `Fn Trait` ä¸ºçº¦æŸçš„æ³›å‹å‚æ•°
3. å‡½æ•°æŒ‡é’ˆå®ç°äº† 3 ä¸­`é—­åŒ… Traitï¼ˆFnã€FnMutã€FnOnceï¼‰` çš„å…¨éƒ¨
* æ‰€ä»¥æ€»æ˜¯å¯ä»¥æŠŠå‡½æ•°æŒ‡é’ˆç”¨ä½œå‚æ•°ä¼ é€’ç»™ä¸€ä¸ªæ¥æ”¶é—­åŒ…çš„å‡½æ•°
* ä¹Ÿæ­£æ˜¯è¿™ä¸ªåŸå› ï¼Œæˆ‘ä»¬å€¾å‘äºæ­é…é—­åŒ… `trait` çš„æ³›å‹æ¥ç¼–å†™å‡½æ•°ï¼šè¿™æ ·è¿™ä¸ªå‡½æ•°å°±å¯ä»¥åŒæ—¶æ¥æ”¶é—­åŒ…å’Œæ™®é€šå‡½æ•°ä½œä¸ºå®ƒçš„å‚æ•°äº†

#### è€Œåœ¨æŸäº›åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬å¯èƒ½åªæƒ³æ¥æ”¶ `fn` è€Œä¸æ¥æ”¶é—­åŒ…ï¼Œåœºæ™¯å¦‚ä¸‹ï¼š
* 1 ä¸å¤–éƒ¨ä¸æ”¯æŒé—­åŒ…çš„ä»£ç äº¤äº’ï¼šC å‡½æ•°

```rust
fn main() {
    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec<String> = list_of_numbers
    .iter()
    /*
        è¿™é‡Œä½¿ç”¨é—­åŒ…
        é—­åŒ…çš„å‚æ•°æ—¶ iï¼Œç„¶åè°ƒç”¨ i çš„ to_string() æ–¹æ³•
     */
    .map(|i| i.to_string())
    .collect();
    println!("list_of_strings is {:#?}", list_of_strings);

    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec<String> = list_of_numbers
    .iter()
    /*
        è¿™é‡Œå°† ToString::to_string å‡½æ•°ä¼ å…¥
     */
    .map(ToString::to_string)
    .collect();

    println!("list_of_strings is {:?}", list_of_strings);

    /*
        map çš„å‚æ•°éœ€è¦å®ç° FnMut Trait 
        è€Œé—­åŒ…å’Œå‡½æ•°æŒ‡é’ˆ ToString::to_string éƒ½å®ç°äº† FnMut Trait
     */
}
```

* å¦ä¸€ä¸ªåˆ—å­

```rust
fn main() {
    enum Status {
        Value(u32),
        Stop,
    }
    /*
        Value(3) ä¸å‡½æ•°è°ƒç”¨ç›¸ä¼¼
        å®é™…ä¸Šè¿™ç§æ„é€ å™¨ç¡®å®è¢«å®ç°æˆäº†å‡½æ•°
        è¿™ä¸ªå‡½æ•°ä¼šæ¥æ”¶ä¸€ä¸ªå‚æ•°å¹¶è¿”å›æ–°çš„å®ä¾‹

        æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠè¿™ç§æ„é€ å™¨ä¹Ÿä½œä¸ºå®ç°äº†é—­åŒ… Trait çš„å‡½æ•°æŒ‡é’ˆæ¥ä½¿ç”¨

     */
    let v = Status::Value(3);

    let list_of_statuses: Vec<Status> = 
    (0u32..20)
    // è¿™é‡Œå°±æ˜¯æŠŠæ„é€ å™¨ç›´æ¥ä¼ å…¥å³å¯
    .map(Status::Value)
    .collect();
}
```

### è¿”å›é—­åŒ…
* é—­åŒ…ä½¿ç”¨ `Trait` è¿›è¡Œè¡¨è¾¾ï¼Œæˆ‘ä»¬æ— æ³•åœ¨å‡½æ•°ä¸­ç›´æ¥è¿”å›ä¸€ä¸ªé—­åŒ…ï¼Œä½†å¯ä»¥å°†ä¸€ä¸ªå®ç°äº†è¯¥ `Trait` çš„å…·ä½“ç±»å‹ä½œä¸ºè¿”å›å€¼

```rust
// è¿™æ ·æƒ³è¿”å›ä¸€ä¸ªé—­åŒ…æ—¶ä¸å¯ä»¥çš„ 
/*
    è¿™æ ·æƒ³è¿”å›ä¸€ä¸ªé—­åŒ…æ—¶ä¸å¯ä»¥çš„ï¼Œç¼–è¯‘æŠ¥é”™
    å› ä¸ºåœ¨ç¼–è¯‘æ—¶æ— æ³•è·å–å…¶å·²çŸ¥çš„å¤§å°
 */
fn returns_closure() -> Fn(i32) -> i32 {
     |x| x + 1
}

// è§£å†³æ–¹æ¡ˆ
// å³å°†å…¶æ”¾åœ¨æŸç§æŒ‡é’ˆçš„åè¾¹
/*
    è§£å†³æ–¹æ¡ˆ
    å³å°†å…¶æ”¾åœ¨æŸç§æŒ‡é’ˆçš„åè¾¹
    è¿™æ—¶å®ƒçš„è¿”å›ç±»å‹å°±æœ‰å›ºå®šçš„å¤§å°äº†ï¼Œç¼–è¯‘å°±ä¸ä¼šå‡ºç°é—®é¢˜äº†
 */
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```


## å® Macro
* å®åœ¨ Rust é‡ŒæŒ‡çš„æ˜¯ä¸€ç»„ç›¸å…³ç‰¹æ€§çš„é›†åˆç§°è°“
1. åŒ…æ‹¬ä½¿ç”¨ `macro_rules!` æ¥æ„å»ºå£°æ˜å®ï¼ˆdeclarative macroï¼‰
2. ä»¥åŠ 3 ç§è¿‡ç¨‹å®

### 3 ç§è¿‡ç¨‹å®
1. è‡ªå®šä¹‰çš„ `#[derive]` å®ï¼Œç”¨äº `struct` å’Œ `enum`ï¼Œå¯ä¸ºå…¶æŒ‡å®šéš `derive` å±æ€§æ·»åŠ çš„ä»£ç 
2. ç±»ä¼¼å±æ€§çš„å®ï¼Œåœ¨ä»»ä½•æ¡ç›®ä¸Šæ·»åŠ è‡ªå®šä¹‰å±æ€§
3. ç±»ä¼¼å‡½æ•°çš„å®ï¼Œçœ‹èµ·æ¥åƒå‡½æ•°è°ƒç”¨ï¼Œå¯ä»¥å¯¹å…¶æŒ‡å®šä¸ºå‚æ•°çš„ token è¿›è¡Œæ“ä½œ

### å‡½æ•°å’Œå®çš„åŒºåˆ«

* å®
1. æœ¬è´¨ä¸Šè®²å®æ˜¯ç”¨æ¥ç¼–å†™å¯ä»¥ç”Ÿæˆå…¶ä»–ä»£ç çš„ä»£ç ï¼ˆå³æ‰€è°“çš„å…ƒç¼–ç¨‹ï¼Œmetaprogrammingï¼‰
2. ç¼–è¯‘å™¨ä¼šåœ¨è§£é‡Šä»£ç å‰æŠŠå®å±•å¼€
3. å®çš„å®šä¹‰è¦æ¯”å‡½æ•°çš„å®šä¹‰å¤æ‚çš„å¤šï¼Œå®æ˜¯éš¾ä»¥é˜…è¯»ã€ç†è§£ã€ç»´æŠ¤çš„
4. åœ¨æŸä¸ªæ–‡ä»¶è°ƒç”¨å®çš„æ—¶å€™ï¼Œå¿…é¡»æå‰å®šä¹‰å®æˆ–å°†å®å¼•å…¥å½“å‰çš„ä½œç”¨åŸŸ


* å‡½æ•°
1. å‡½æ•°åœ¨å®šä¹‰ç­¾åçš„æ—¶å€™ï¼Œå¿…é¡»å£°æ˜å‚æ•°çš„ä¸ªæ•°å’Œç±»å‹ï¼Œè€Œå®å¯ä»¥å¤„ç†å¯å˜çš„å‚æ•°
2. è€Œå‡½æ•°å¯ä»¥åœ¨ä»»ä½•ä½ç½®å®šä¹‰å¹¶åœ¨ä»»ä½•ä½ç½®ä½¿ç”¨

### `macro_rules!` å£°æ˜å®ï¼ˆå¯èƒ½ä¼šå¼ƒç”¨ï¼‰
* æˆ–å«å®æ¨¡ç‰ˆ
* Rust ä¸­æœ€å¸¸è§çš„å®å½¢å¼ï¼šå£°æ˜å®
1. ç±»ä¼¼äº `match` è¡¨è¾¾å¼çš„åŒ¹é…æ¨¡å¼
2. åœ¨å®šä¹‰å£°æ˜å®æ—¶ï¼Œéœ€è¦ä½¿ç”¨ `macro_rules!`


```rust
//let v: Vec<u32> = vec![1, 2, 3];

/*
    çœ‹ä¸€ä¸‹ vec! å®çš„ç®€å•å®ç°

    #[macro_export] è¡¨æ˜è¿™ä¸ªå®åœ¨å®ƒæ‰€åœ¨çš„åŒ…è¢«å¼•å…¥ä½œç”¨åŸŸåæ‰èƒ½ä½¿ç”¨ï¼Œ
    ç¼ºå°‘è¿™ä¸ªæ ‡æ³¨çš„å®å°±ä¸èƒ½è¢«å¼•å…¥ä½œç”¨åŸŸ

    å®åç§°æ˜¯ vec
 */
#[macro_export]
macro_rules! vec {
    /*
        è¿™é‡Œå¼€å§‹å°±æ˜¯å®çš„å®šä¹‰ä½“
        è¿™é‡Œç±»ä¼¼äº match çš„æ¨¡å¼åŒ¹é…ï¼ˆåˆ†æ”¯ï¼‰ï¼Œè€Œè¿™é‡Œåªæœ‰ä¸€ä¸ªåˆ†æ”¯

        ( $($x:expr), *) å°±æ˜¯å®ƒçš„åŒ¹é…æ¨¡å¼
        => åå°±æ˜¯å…¶å¯¹åº”çš„ä»£ç 
        
        è¿™ä¸ªå®åªå­˜åœ¨ä¸€ç§æœ‰æ•ˆçš„åŒ¹é…æ¨¡å¼ï¼Œå…¶ä»–æ¨¡å¼éƒ½ä¼šå¯¼è‡´ç¼–è¯‘æ—¶çš„é”™è¯¯
        è€ŒæŸäº›æ¯”è¾ƒå¤æ‚çš„å®ä»–ä»¬å°±å¯èƒ½åŒ…å«å¤šä¸ªåˆ†æ”¯
        è¿™ä¸ match è¡¨è¾¾å¼è¿˜æ˜¯æœ‰æœ¬è´¨åŒºåˆ«çš„ï¼Œmatch è¡¨è¾¾å¼å®ƒåŒ¹é…çš„æ˜¯å€¼
        è€Œè¿™é‡Œçš„å®åŒ¹é…çš„æ˜¯ Rust çš„ä»£ç ç»“æ„

        ä»£ç è§£é‡Š
        $x:expr è¡¨ç¤ºå¯ä»¥åŒ¹é…ä»»ä½•çš„ Rust è¡¨è¾¾å¼ï¼Œç„¶åæŠŠå®ƒå‘½åä¸º $x
        , æ„å‘³ç€ä¸€ä¸ªå¯èƒ½çš„é€—å·åˆ†éš”ç¬¦ä¼šå‡ºç°åœ¨æ•è·ä»£ç çš„åè¾¹
        * è¡¨ç¤ºèƒ½å¤ŸåŒ¹é… 0 ä¸ªæˆ–å¤šä¸ª * ä¹‹å‰çš„ä¸œè¥¿
        æ‰€ä»¥è¿™ä¸ªä¾‹å­ ( $x:expr ), *) å°±æ˜¯åŒ¹é…ä¸Šè¾¹ 1, 2, 3 è¿™ä¸‰ä¸ªè¡¨è¾¾å¼  
     */
    ( $( $x:expr ), *) => {
        {
            let mut temp_vec = Vec::new();
            $(
                /*
                    æ¯æ¬¡åŒ¹é…éƒ½ä¼šç”Ÿæˆè¿™æ ·çš„ä»£ç 
                    æœ¬ä¾‹å°±æ˜¯ï¼š
                    push(1)
                    push(2)
                    push(3)
                 */
                temp_vec.push($x);
            )*
            // è¿”å› Vec
            temp_vec 
        }
    };
}


è¿™ä¸ªå®æœ€åä»£ç ç±»ä¼¼äºè¿™æ ·
// let mut temp_vec = Vec::new();
// temp_vec.push(1);
// temp_vec.push(2);
// temp_vec.push(3);
// temp_vec
```

> å¤§éƒ¨åˆ†ç¨‹åºå‘˜åªæ˜¯ç”¨ï¼Œä¸€èˆ¬ä¸ä¼šç¼–å†™å®
{: .prompt-info }


### åŸºäºå±æ€§æ¥ç”Ÿæˆä»£ç çš„è¿‡ç¨‹å®
* æ˜¯ä¹‹åæ›¿ä»£ `macro_rules!` çš„å®

* è¿™ç§å½¢å¼æ›´åƒå‡½æ•°ï¼ˆæŸç§å½¢å¼çš„è¿‡ç¨‹ï¼‰
1. æ¥æ”¶å¹¶æ“ä½œè¾“å…¥çš„ Rust ä»£ç 
2. ç„¶åç”Ÿæˆå¦å¤–ä¸€äº› Rust ä»£ç ä½œä¸ºç»“æœ

* ä¸‰ç§è¿‡ç¨‹å®
1. è‡ªå®šä¹‰æ´¾ç”Ÿ
2. å±æ€§å®
3. å‡½æ•°å®

* åˆ›å»ºè¿‡ç¨‹å®æ—¶
1. å®å®šä¹‰å¿…é¡»å•ç‹¬æ”¾åœ¨å®ƒä»¬è‡ªå·±çš„åŒ…ä¸­ï¼Œå¹¶ä¸”ä½¿ç”¨ç‰¹æ®Šçš„åŒ…ç±»å‹

```rust
use proc_macro;

// some_attribute ç”¨æ¥æŒ‡å®šè¿‡ç¨‹å®çš„å ä½ç¬¦
#[some_attribute]
/*
    å®šä¹‰äº†è¿‡ç¨‹å®çš„å‡½æ•°

    TokenStream è¡¨ç¤ºä¸€æ®µæ ‡è®°åºåˆ—ï¼Œåœ¨ proc_macro ä¸­å®šä¹‰
    è¿™ä¹Ÿæ˜¯è¿‡ç¨‹å®çš„æ ¸å¿ƒ
    
    éœ€è¦è¢«å®å¤„ç†çš„ç»„æˆäº†å‚æ•° TokenStream
    ç»“æœ TokenStream å°±æ˜¯å¤„ç†åçš„

    å‡½æ•°é™„å¸¦çš„å±æ€§å°±å†³å®šæˆ‘ä»¬åˆ›å»ºçš„æ˜¯å“ªç§è¿‡ç¨‹å®
    åŒä¸€ä¸ªåŒ…ä¸­å¯ä»¥æœ‰å¤šç§ä¸åŒçš„è¿‡ç¨‹å®

 */
pub fn some_name(input: TokenStream) -> TokenStream {
    
}
```

### 1 è‡ªå®šä¹‰ deriveï¼ˆæ´¾ç”Ÿï¼‰å®
* éœ€æ±‚ï¼šåˆ›å»ºä¸€ä¸ª hello_macro åŒ…ï¼Œå®šä¹‰ä¸€ä¸ªæ‹¥æœ‰å…³è”å‡½æ•° hello_macro çš„ HelloMacro trait
* æˆ‘ä»¬éœ€è¦æä¾›ä¸€ä¸ªèƒ½è‡ªåŠ¨å®ç° trait çš„è¿‡ç¨‹å®
* åœ¨å®ƒä»¬çš„ç±»å‹ä¸Šæ ‡æ³¨ `#[derive(HelloMacro)]`ï¼Œè¿›è€Œå¾—åˆ° hello_macro çš„é»˜è®¤å®ç°

```shell
$ mkdir derive-19
$ cd derive-19
$ vim Cargo.toml
$ cargo new hello_macro --lib
$ cargo new hello_macro_derive --lib
```

* workspace

```rust
[workspace]

members = [
    "hello_macro",
    "hello_macro_derive",
    "Pancakes",
]
```

* hello_macro çš„ lib.rs

```rust
pub trait HelloMacro {
    fn hello_macro();
}
```

* hello_macro_derive çš„ lib.rs

```rust
extern crate proc_macro;

// 
/*
    å€ŸåŠ© proc_macro æä¾›çš„ç¼–è¯‘å™¨æ¥å£ä»è€Œåœ¨ä»£ç ä¸­è¯»å–å’Œæ“ä½œ Rust ä»£ç 
    è€Œç”±äºå®ƒå·²ç»è¢«å†…ç½®åœ¨ Rust é‡Œäº†ï¼Œæ‰€ä»¥ä¸éœ€è¦æ·»åŠ å®ƒåˆ° Cargo.toml ä¸­çš„ä¾èµ–
 */
use crate::proc_macro::TokenStream;

/*
    å°† syn äº§ç”Ÿçš„æ•°æ®ç»“æ„é‡æ–°è½¬åŒ–ä¸º Rust ä»£ç 
 */
use quote::quote;

/*
    syn ç”¨äºæŠŠ Rust ä»£ç ä»å­—ç¬¦ä¸²è½¬åŒ–ä¸ºå¯ä¾›æˆ‘ä»¬æ“ä½œçš„æ•°æ®ç»“æ„
 */
use syn;

/*
    å½“åˆ«äººå†™ #[derive(HelloMacro)] æ—¶ï¼Œ
    hello_macro_derive å‡½æ•°å°±ä¼šè‡ªåŠ¨è¢«è°ƒç”¨

    ä¸ºä»€ä¹ˆä¼šè‡ªåŠ¨è°ƒç”¨å‘¢ï¼Ÿå°±æ˜¯å› ä¸º hello_macro_derive ä¸Šè¾¹
    æ ‡æ³¨äº† #[proc_macro_derive(HelloMacro)]ï¼Œæˆ‘ä»¬æŒ‡æ˜äº† HelloMacro trait

    è€Œ hello_macro_derive å‡½æ•°ï¼Œé¦–å…ˆä¼šæŠŠ input è½¬åŒ–è§£é‡Šæˆæˆ‘ä»¬å¯æ“ä½œçš„æ•°æ®ç»“æ„


 */

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // æœ¬å‡½æ•°è´Ÿè´£è§£æ TokenStream
    // è¿™ä¸ªå‡½æ•°ç­¾åå¯¹äºä½ åˆ›å»ºå…¶ä»–è¿‡ç¨‹å®å…¶å®åŸºæœ¬æ˜¯ä¸€æ ·çš„
    // ä¸åŒçš„æ˜¯ä¸‹è¾¹çš„ impl_hello_macro 

    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    // parse å‡½æ•°æ¥å— TokenStream å¹¶è¿”å› DeriveInput ç»“æ„ä½“
    // DeriveInput ä»£è¡¨äº†è§£æåçš„ Rust ä»£ç 
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    // è´Ÿè´£è½¬åŒ–è¯­æ³•æ ‘ï¼Œå³æœ€åç”Ÿæˆ Rust ä»£ç çš„åœ°æ–¹
    impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    // Ident ç»“æ„ä½“ï¼Œè¿™é‡Œæœ‰è¢«æ ‡æ³¨ç±»å‹çš„åç§°
    let name = &ast.ident;
    /*
        quote! å®ï¼Œå®šä¹‰è¿”å›çš„é‚£äº› Rust ä»£ç 
        å°±è¿”å› impl çš„ä»£ç 

        quote! å®çš„ç»“æœæ˜¯ç¼–è¯‘å™¨æ— æ³•ç›´æ¥ç†è§£çš„ç±»å‹ï¼Œ
        æ‰€ä»¥éœ€è¦æŠŠç»“æœè½¬åŒ–ä¸º TokenStream
        é€šè¿‡è°ƒç”¨ into() æ–¹æ³•è½¬åŒ–ä¸º TokenStream

        #name ä¼šè¢«æ›¿æ¢ä¸ºå˜é‡ name çš„å€¼
     */
    /*
        stringify! å®ï¼Œå®ƒæ˜¯ Rust å†…ç½®çš„ï¼Œ
        å®ƒæ¥æ”¶ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¾‹å¦‚ 1+2ï¼Œå¹¶æŠŠå…¶æŠ“ä¸ºå­—ç¬¦ä¸²å­—é¢å€¼ ("1+2")
     */
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}", stringify!(#name));
            }
        }
    };
    gen.into()

}
```

* Pancakes ä½¿ç”¨ HelloMacro å®çš„ç»“æ„ä½“

```rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

/*
    æ•ˆæœå°±æ˜¯ç”¨æˆ·åœ¨è‡ªå·±çš„ struct ä¸Š derive(HelloMacro)
    è®©è‡ªå·±çš„ç±»å‹èƒ½è·å¾— HelloMacro çš„é»˜è®¤å®ç°
 */
#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```

### 2 ç±»å‹å±æ€§å®
* å±æ€§å®ä¸è‡ªå®šä¹‰ `derive` å®ç±»ä¼¼
1. å…è®¸åˆ›å»ºæ–°çš„å±æ€§
2. ä½†ä¸æ˜¯ä¸º `derive` å±æ€§ç”Ÿæˆä»£ç 


* å±æ€§å®æ›´åŠ çµæ´»
1. `derive` å®åªèƒ½ç”¨äº `struct` å’Œ `enum`
2. è€Œå±æ€§å®å¯ä»¥ç”¨äºä»»æ„æ¡ç›®ï¼Œä¾‹å¦‚å‡½æ•°

* å±æ€§å®çš„å·¥ä½œæ–¹å¼ä¸è‡ªå®šä¹‰ `derive` å®å‡ ä¹ä¸€æ ·ï¼Œéƒ½éœ€è¦å»ºç«‹ä¸€ä¸ª `proc_macro_attribute` çš„åŒ…ï¼Œå¹¶æä¾›ç›¸åº”ä»£ç çš„å‡½æ•°


```rust
/*
    route æ˜¯ç”¨äºåšè·¯ç”±çš„
    è¿™é‡Œå¦‚æœæ–¹æ³•æ˜¯ GETï¼Œå°±ä¼šèµ°åˆ°ä¸‹è¾¹çš„ index å‡½æ•°ä¸­
    è€Œ route å°±æ˜¯è¿‡ç¨‹å®å®šä¹‰çš„
 */
#[route(GET, "/")]
fn index() {

}

/*
    è¿™å°±æ˜¯ route å®çš„å‡½æ•°ç­¾å
    attr å°±å¯¹åº” route(GET, "/") çš„ GET å’Œè·¯å¾„ "/"
    item å°±å¯¹åº”å‡½æ•°ä½“ï¼Œè¿™é‡Œå°±æ˜¯ index å‡½æ•°
 */
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {

}
```

### 3 å‡½æ•°å®
* å‡½æ•°å®å®šä¹‰ç±»ä¼¼äºå‡½æ•°è°ƒç”¨çš„å®ï¼Œä½†æ¯”æ™®é€šå‡½æ•°æ›´åŠ çµæ´»
* å‡½æ•°å®å¯ä»¥æ¥æ”¶ TokenStream ä½œä¸ºå‚æ•°
* ä¸å¦å¤–ä¸¤ç§è¿‡ç¨‹å®ä¸€æ ·ï¼Œåœ¨å®šä¹‰ä¸­ä½¿ç”¨ Rust ä»£ç æ¥æ“ä½œ TokenStream
* å·¥ä½œæ–¹å¼ä¸è‡ªå®šä¹‰ derive å®ç±»ä¼¼ï¼Œä¹Ÿéœ€è¦å»ºç«‹ä¸€ä¸ª proc_macro çš„åŒ…ï¼Œå¹¶æä¾›ç›¸åº”ä»£ç çš„å‡½æ•°

```rust
/*
    å®šä¹‰ä¸€ä¸ªè§£æ SQL è¯­å¥çš„å®
 */
let sql = sql!(SELECT * FROM posts WHERE id=1);

#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {

}
```

