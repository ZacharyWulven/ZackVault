---
layout: post
title: Full Stack Web3-04-Lottery-Raffle
date: 2022-11-02 16:45:30.000000000 +09:00
categories: [区块链, chainlink 公开课]
tags: [区块链, chainlink 公开课]
---

# Hardhat Smart Contract Lottery/Raffle ( Lesson 9)

本节课制作 FundMe 合约的前端
Full Stack = Smart Contracts（backend）+ HTML / Javascript / Website stuff (front e   nd)

## 0x01 Hardhat setup
参考：https://github.com/smartcontractkit/full-blockchain-solidity-course-js#lesson-9-hardhat-smart-contract-lottery

``` console
1 $ mkdir hh-contract-lottery-fcc
2 $ cd hh-contract-lottery-fcc
3 $ code .
4 $ yarn add --dev hardhat 
5 $ yarn hardhat 选择空模板创建项目
6 安装所有依赖
$ yarn add --dev @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers \
ethers @nomiclabs/hardhat-etherscan @nomiclabs/hardhat-waffle chai \
ethereum-waffle hardhat hardhat-contract-sizer hardhat-deploy \
hardhat-gas-reporter prettier prettier-plugin-solidity solhint \
solidity-coverage dotenv
```

### Write Contract Code
1. 在根目录 mkdir contracts 目录
2. Raffle.sol
3. [Event 参考](https://www.youtube.com/watch?v=KDYJC85eS5M)

### Tips
```
1 external 比 public 更省 gas
2 带 virtual 方法表示期望被 override
```

## 0x02 Chainlink VRF (Randomness in Web3)
[Chainlink VRF 文档](https://docs.chain.link/vrf/v2/subscription/examples/get-a-random-number)
[Open subscription Manager](https://vrf.chain.link/?_ga=2.214098708.2047585917.1669966594-236993336.1663668981)

1 Raffle 合约 import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

```console
2 $ yarn add --dev @chainlink/contracts
```

3 继承 VRFConsumerBaseV2，contract Raffle is VRFConsumerBaseV2 { }

### Hardhat Shorthand 简化输入的命令
1 安装 hardhat-shorthand

```console
$ yarn global add hardhat-shorthand

$ hh compile 等于 $ yarn hardhat compile
```

### 实现 VRF Request
[get subscriptionId 等一些参数](https://vrf.chain.link/?_ga=2.218722074.2047585917.1669966594-236993336.1663668981)

VRF 获取随机数代码

```
    // 已经产生 Winner
    // 实际是 Chainlink 调用这个方法
    function fulfillRandomWords(
        uint256 /* requestId 用不到参数可以注释掉，只声明类型 */,
        uint256[] memory randomWords
    ) internal override {
        uint256 indexOfWinner = randomWords[0] % s_players.length;
        address payable recentWinner = s_players[indexOfWinner];
        s_recentWinner = recentWinner;
        s_raffleState = RaffleState.OPEN;
        s_players = new address payable[](0);
        s_lastTimeStamp = block.timestamp;
        (bool success, ) = recentWinner.call{value: address(this).balance}("");
        //require(success, "");
        if (!success) {
            revert Raffle__TransferFailed();
        }
        emit WinnerPicked(recentWinner);
    }
```

## 0x03 Chainlink Automation（以前叫 Chainlink Keeper）
[用于自动触发合约](https://docs.chain.link/chainlink-automation/compatible-contracts/)
[Sample](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Automation/AutomationCounter.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js)

checkUpkeep 函数表示是时候得到一个随机数了么

### Chainlink Automation 代码
```
    /**
     * @dev This is the function that the Chainlink Keeper nodes call
     * they look for the `performUpkeep` to return true
     * if checkUpkeep return true means need a random number
     * The following should be true in order to return true:
     * 1. Our time interval should have passed
     * 2. The lottery should have at least 1 player, and have some ETH
     * 3. Our subscription is funded with LINK
     * 4. The lottery should be in an "open" state.
     */
    // performData 允许任何想要东西，即我们可以调用其他方法做更高级的事
    function checkUpkeep(
        bytes memory /* checkData */
    ) public view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        // We don't use the checkData in this  example. The checkData is defined when the Upkeep was registered.
        bool isOpen = (RaffleState.OPEN == s_raffleState);
        bool timePassed = ((block.timestamp - s_lastTimeStamp) > i_interval);
        bool hasPlayers = (s_players.length > 0);
        bool hasBalance = (address(this).balance > 0);
        // 当条件满足触发 `performUpkeep` 去抽奖
        upkeepNeeded = (isOpen && timePassed && hasPlayers && hasBalance);
    }

    // external 比 public 更省 gas
    // 请求获得 Winner
    // 实际是 Chainlink 调用这个方法
    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function

        // Request the random number
        // Once we get it, do something with it
        // 2 transaction process
        // 随机数请求函数，使用 chainlink 随机数决定获胜者

        /* fix compile error for checkUpkeep("")
         * 字符串 不适用于 calldata，所以要改成 memory
         */
        (bool upkeepNeeded, ) = checkUpkeep("");
        if (!upkeepNeeded) {
            revert Raffle__UpkeepNotNeeded(
                address(this).balance,
                s_players.length,
                uint256(s_raffleState)
            );
        }

        s_raffleState = RaffleState.CALCULATING;

        uint256 requestId = i_vrfCoordinator.requestRandomWords(
            i_gasLane, // gasLane
            i_subscriptionId,
            REQUEST_CONFIRMATIONS, // 等待区块数量
            i_callbackGasLimit,
            NUM_WORDS
        );
        emit RequestedRaffleWinner(requestId);
    }
```

## 0x04 Unit Tests
```console
$ hh test --grep "updates the raffle state"


编辑 hardhat.config.js 添加如下
    mocha: {
        timeout: 200000, // 200 seconds max
    },
```

## 0x05 Staging Tests
Step 1 确保有足够的 eth 和 link
[LINK Token 水管](https://docs.chain.link/resources/link-token-contracts)

Step 2 创建 subscriptionId [Create Subscription](https://vrf.chain.link/)

![image](/assets/web3-full/vrf-01.png)
![image](/assets/web3-full/vrf-03.png)

这里创建的 subscriptionId 是 7503，下图的 consumer 就是抽奖者
![image](/assets/web3-full/vrf-04.png)

将 subscriptionId 填入 helper-hardhat-config.js 中的 goerli 中的 subscriptionId 字段

Step 3 Add Funds 输入 2，创建 2 个连接，我们支付 gas 费以便后续获得随机数

- [VRF相关文档](https://docs.chain.link/vrf/v2/subscription/supported-networks)

- link 推荐 [web3-full-course](https://github.com/smartcontractkit/full-blockchain-solidity-course-js#lesson-9-hardhat-smart-contract-lottery)

![image](/assets/web3-full/vrf-02.png)

Step 4 部署合约
```console
yarn hardhat deploy --network goerli

// 或者安装了插件的可以这样
hh deploy --network goerli
```
[合约地址](https://goerli.etherscan.io/address/0x5908F32bcc3bCBD0714585A4b7eF9DEAB7d7fe83)

Step 5 add consumers
将合约地址添加到 VRF consumer
![image](/assets/web3-full/vrf-05.png)

Step 6 注册 Chainlink Automation（以前叫 Chainlink Keepers）
[automation](https://automation.chain.link/)
