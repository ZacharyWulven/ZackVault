---
layout: post
title: Move-02-è¿›é˜¶
date: 2022-09-02 16:45:30.000000000 +09:00
tag: åŒºå—é“¾
---

## 0x01 è¿›é˜¶è®¡åˆ’
* ç±»å‹èƒ½åŠ›
* æ‰€æœ‰æƒ
* ç»“æ„ä½“
* é¢å‘èµ„æºç¼–ç¨‹
* åˆçº¦é¡¹ç›®å®æˆ˜

## 0x02 ç±»å‹èƒ½åŠ›
Move çš„ç±»å‹æœ‰å‡ ç§èƒ½åŠ›
* Copy å¯ä»¥è¢«å¤åˆ¶ï¼ŒMove åŸç”Ÿæ•°æ®ç±»å‹å…·å¤‡è¿™ä¸ªèƒ½åŠ›
* Drop å¯ä»¥è¢«ä¸¢å¼ƒï¼ŒMove åŸç”Ÿæ•°æ®ç±»å‹å…·å¤‡è¿™ä¸ªèƒ½åŠ›
* Key å¯ä»¥ä½œä¸ºé”®å€¼
* Store å¯ä»¥å­˜å‚¨åˆ°å…¨å±€çŠ¶æ€ï¼ŒMove åŸç”Ÿæ•°æ®ç±»å‹å…·å¤‡è¿™ä¸ªèƒ½åŠ›

{% highlight ruby %}
Move åŸç”Ÿæ•°æ®ç±»å‹ï¼ˆæ•´å‹ã€å¸ƒå°”ã€Addressï¼‰å¤©ç”Ÿå…·å¤‡ Copyã€Dropã€Store èƒ½åŠ›
{% endhighlight %}

## 0x03 è‡ªå®šä¹‰ç»“æ„
{% highlight ruby %}
è¯­æ³•
Name è¦é¦–å­—æ¯å¤§å†™
struct  {Name} {
  FIELD1: TYPE1,
  FIELD2: TYPE2,
  ...
}
è§„åˆ™ï¼š
1 å­—æ®µå¯ä»¥æ˜¯ 0~65535
2 ç±»å‹å¯ä»¥æ˜¯åŸç”Ÿç±»å‹ä»¥åŠè‡ªå®šä¹‰ç±»å‹ï¼Œä¸å…è®¸ç±»å‹é€’å½’
{% endhighlight %}

### Student
{% highlight ruby %}
module ä¹Ÿå¯ä»¥è¿™ä¹ˆå†™

address Viper {
    module Student {
        struct Empty {}

        // define Student struct
        struct Student has drop {
            id: u64,
            age: u8,
            sex: bool,
        }

        // constructor æ„é€ å‡½æ•°
        public fun new_student(_id: u64, _age: u8, _sex: bool): Student {
            Student{
                id: _id,
                age: _age,
                sex: _sex,
            }
        }     
        
        å¦‚æœå‚æ•°åä¸ struct çš„å­—æ®µåç§°ä¸€æ ·å¯ä»¥ç›´æ¥èµ‹å€¼
        public fun new_student2(id: u64, age: u8, sex: bool): Student {
            Student{
                id,
                age,
                sex,
            }
        }         

        public fun get_id(s: Student): u64 {
            // need ability of drop
            // define struct Student has drop
            s.id
        }

    }
}
{% endhighlight %}

### ç»“æ„ä½“æ³›å‹
{% highlight ruby %}
        struct User<T1, T2> has drop {
            id: T1,
            age: T2,
        }

        public fun new_user<T1, T2>(id: T1, age: T2): User<T1, T2> {
            User{ id, age,}
        }


            // can automatic infer
        let user = Student::new_user(1002, 30);

        let user1 = Student::new_user<u64, u8>(1003, 40);

        Debug::print(&user1);
{% endhighlight %}


## 0x04 æ‰€æœ‰æƒ
* æ¯ä¸ªå˜é‡éƒ½æœ‰æ‰€æœ‰æƒ
* æ‰€æœ‰æƒçš„å±ä¸»æ˜¯ä½œç”¨åŸŸ
1. move å±æ€§è½¬ç§»æ“ä½œï¼Œç§»äº¤æ‰€æœ‰æƒ
2. copy æ‹·è´å€¼ï¼Œä¸ç§»äº¤æ‰€æœ‰æƒ

è¿˜æœ‰å¼•ç”¨ä¼ é€’ï¼Œmove è®¾è®¡ç†å¿µå˜é‡è¢«åˆ›å»ºå‡ºæ¥åªèƒ½è¢«ä¼ é€’
{% highlight ruby %}
case1   å¯è¿è¡Œ
        let aa = 10;
        Math::show(aa);
        Math::show(aa); å¯æ­£å¸¸è¿è¡Œï¼Œå› ä¸ºé»˜è®¤ move ä¼ å€¼æ˜¯æ‹·è´

case2   æŠ¥é”™
        let aa = 10;
        Math::show(move aa); åŸæ¥ aa æ‰€æœ‰æƒåœ¨ main å‡½æ•°ï¼Œ
        ä½¿ç”¨ move åæŠŠ aa æ‰€æœ‰æƒè½¬ç§»ç»™äº† Math::show å‡½æ•°ï¼Œ
        å½“æœ¬æ¬¡ show è°ƒç”¨å®Œ aa æ— æ³•å†æ¬¡ä½¿ç”¨
        Math::show(aa);
        
case3   å¯è¿è¡Œ
        let aa = 10;
        Math::show(copy aa); é»˜è®¤å°±æ˜¯ copyï¼Œå€¼ä¼ é€’æ‹·è´
        Math::show(copy aa);
{% endhighlight %}

## 0x05 Signer
* Signer ä»£è¡¨å‘é€äº¤æ˜“çš„äººæˆ–ç­¾åçš„äºº
* ä¸€ç§åŸç”Ÿçš„æ•°æ®ç±»å‹
* åªæœ‰ä¸€ç§èƒ½åŠ›ï¼šå³ Dropï¼ˆåªæœ‰è¢«ä¸¢å¼ƒçš„èƒ½åŠ› ğŸ˜‚ï¼‰
{% highlight ruby %}
å¯ä»¥è¿™æ ·ç†è§£ struct signer has drop { a: address }
{% endhighlight %}
* ä¸èƒ½åœ¨ä»£ç ä¸­åˆ›å»ºï¼Œå¿…é¡»é€šè¿‡è„šæœ¬è°ƒç”¨ä¼ é€’
 
### Signer ç›¸å…³ API
1. address_of(&Signer):address è¿”å› Signer ä¸­çš„åœ°å€
2. borrow_address(&Signer):&address è¿”å› Signer ä¸­åœ°å€çš„å¼•ç”¨

{% highlight ruby %}

script {
    use 0x1::Signer;
    use 0x1::Debug;

    script çš„ main å‡½æ•°å¯ä»¥æœ‰å¤šä¸ªå‚æ•°ï¼Œä½†å¦‚æœæœ‰ signerï¼Œsigner éœ€è¦åœ¨å‰è¾¹
    fun test_signer(sn: signer) {
        let addr = Signer::address_of(&sn);
        Debug::print(&addr);
    }
}
{% endhighlight %}

## 0x06 èµ„æº
* èµ„æºå°±æ˜¯è¢«é™åˆ¶äº†èƒ½åŠ›çš„ç»“æ„ä½“
* èµ„æºåªèƒ½æœ‰ key å’Œ store ä¸¤ç§èƒ½åŠ›
* èµ„æºå¿…é¡»å­˜å‚¨åœ¨è´¦æˆ·ä¸‹ï¼Œè´¦æˆ·å¯ä»¥ç†è§£ä¸ºå°±æ˜¯ Signer
* ä¸€ä¸ªè´¦æˆ·åŒä¸€æ—¶åˆ»åªèƒ½å®¹çº³ä¸€ä¸ªèµ„æº

èµ„æºç›¸å…³ API

![](/assets/images/move/resource.png)


{% highlight ruby %}
module Viper::Collection {
    use 0x1::Vector;
    use 0x1::Signer;

    struct Item has store, drop { }

    // define resources
    struct Collection has key, store {
        items: vector<Item>,
    }

    // create move åˆ›å»ºèµ„æº
    public fun make_collection(account: &signer) {
       // set collection to account
        move_to<Collection>(account, Collection{
            items: Vector::empty<Item>()
        })
    }

    // check exist æ£€æŸ¥èµ„æºæ˜¯å¦å­˜åœ¨
    public fun exists_at(addr: address): bool {
        exists<Collection>(addr)
    }

    // update resource  æ›´æ–°èµ„æº
    // need "acquires resources_name" if u use borrow_global_mut function 
    // ä½¿ç”¨äº† borrow_global_mut çš„å‡½æ•°å£°æ˜éœ€è¦åŠ  acquires èµ„æºå
    public fun add_item(account: &signer) acquires Collection {
        let addr = Signer::address_of(account);
        let collection = borrow_global_mut<Collection>(addr);
        // add new item to collection items
        Vector::push_back(&mut collection.items, Item{});

    }

    public fun size(account: &signer): u64 acquires Collection {
        let addr = Signer::address_of(account);
        let collection = borrow_global<Collection>(addr);
        // Note : implicit return can not has ";"
        Vector::length(&collection.items)
    }

    // é”€æ¯èµ„æº
    // { items: _ } ä¸­â€œä¸‹åˆ’çº¿â€è¡¨ç¤ºä¸æ¥å—ä»»ä½•å…ƒç´ ï¼Œè¿™æ ·è¿›è¡Œé”€æ¯
    public fun destroy(account: &signer) acquires Collection {
        let addr = Signer::address_of(account);
        let collection = move_from<Collection>(addr);
        let Collection{ items: _ } = collection; // é”€æ¯èµ„æº
    }

}


--------------------
script {
    use 0x1::Debug;
    use Viper::Collection;
    use 0x1::Signer;

    fun test_resourses(account: signer) {

        Collection::make_collection(&account);
        let addr = Signer::address_of(&account);
    //    let addr = @0x41; 
        let exist = Collection::exists_at(addr);
        Debug::print(&exist);


    }

}

è¾“å‡º
debug: true
18:43:03
Gas used: 17
Changed resource(s) under 1 address(es):

èµ„æºæ“ä½œæœ‰ç›¸å…³çš„ log
Changed 1 resource(s) under address 0000000000000000000000000000000000000000000000000000000000000042:
    Added type 0x2::Collection::Collection: [0] (wrote 57 bytes)
      store key 0x2::Collection::Collection {
          items: [
          ]
      }
Wrote 57 bytes of resource ID's and data
{% endhighlight %}

## 0x07 æºç åˆ†æ
Storage æºç åˆ†æ
{% highlight ruby %}
/// The storage module example.
/// It's utilizing Move language generics to store any kind of data under user account as resource.
/// The `scripts` folder contains example which utilizing Storage module.
/// To get familiar with generics, resources, and other Move concepts visit https://diem.github.io/move/introduction.html
module Sender::Storage {
    use Std::Signer;

    /// Define `Storage` resource.
    /// The resource would store `T` (generic) kind of data under `val` field.
    struct Storage<T: store> has key {
        val: T,
    }

    /// Store the `val` under user account in `Storage` resource.
    /// `signer` - transaction sender.
    /// `val` - the value to store.
    public fun store<T: store>(account: &signer, val: T) {
        // Get address of `signer` by utilizing `Signer` module of Standard Library
        let addr = Signer::address_of(account);

        // Check if resource isn't exists already, otherwise throw error with code 101.
        assert!(!exists<Storage<T>>(addr), 101);

        // Create `Storage` resource contains provided value.
        let to_store = Storage {
            val,
        };

        // 'Move' the Storage resource under user account,
        // so the resource will be placed into storage under user account.
        move_to(account, to_store);
    }

    /// Get stored value under signer account.
    /// `signer` - transaction sender, which stored value.
    public fun get<T: store>(account: &signer): T acquires Storage {
        // Get address of account.
        let addr = Signer::address_of(account);

        // Check if resource exists on address, otherwise throw error with code 102.
        assert!(exists<Storage<T>>(addr), 102);

        // Extract `Storage` resource from signer account.
        // And then deconstruct resource to get stored value.
        let Storage { val } = move_from<Storage<T>>(addr);  // å–å‡º
        val
    }
}

script {
    use Sender::Storage;

    /// Script to store `vector<u8>` (bytes).
    fun store_bytes(account: signer, val: vector<u8>) {
        Storage::store(&account, val);
    }
}


æµ‹è¯• store_bytes(0x1, b"123")
{% endhighlight %}

Coins 
{% highlight ruby %}

/// An example of how you can implement balance and coins logic WITHOUT Aptos Framework, but in Move.
/// Could be useful if you indeed want to learn how it works in Background in Move.
///
/// THIS IS JUST EXAMPLE AND NOT FOR PRODUCTION USAGE.
///
/// Current example support only one Coins type, but for production you probably should replace `Coins` with generic type
/// (in functions, during `Balance` definition, etc).
///
/// 1. `Coins` resource is used as coin/token type, usually in your production code it can be any type which can
///    be stored in Balance resource (generic), yet to make an example simple we introduced `Coins` type.
/// 2. `Balance` resource storing balance of `Coins` under user account.
///
/// To get familiar with generics, resources, and other Move concepts visit https://diem.github.io/move/introduction.html
///
/// If you are interested in production examples of Balances/Tokens/Coins implementation, look at Standard Library:
///     * https://github.com/pontem-network/pont-stdlib/blob/master/sources/PontAccount.move
///     * https://github.com/pontem-network/pont-stdlib/blob/master/sources/Token.move
module Sender::Coins {
    use Std::Signer;

    /// This is `Coins` Move resource corresponds to some number of coins.
    /// In Move, all struct objects can have "abilities" from a hardcoded set of {copy, key, store, drop}.
    /// This one has only `store` ability, which means it can be a part of root level resource in Move Storage.
    struct Coins has store { val: u64 }

    /// This is `Balance` Move resource representing user balance stored under account.
    /// This is Move resource object which is marked by `key` ability. It can be added to the Move Storage directly.
    struct Balance has key {
        /// It contains an amount of `Coins` inside.
        coins: Coins
    }

    /// Error when `Balance` doesn't exist on account.
    const ERR_BALANCE_NOT_EXISTS: u64 = 101;
    /// Error when `Balance` already exists on account.
    const ERR_BALANCE_EXISTS: u64 = 102;

    /// In Move you cannot directly create an instance of `Coin` from script,
    /// Instead you need to use available constructor methods. In general case, those methods could have some permission
    /// restrictions, i.e. `mint(acc, val: u64)` method would require `&signer` of coin creator as the first argument
    /// which is only available in transactions signed by that account.
    ///
    /// In the current example anyone can mint as many coins as want, but usually you can add restrictions (MintCapabilities),
    /// for details look at standard library (links in the herd of the file).
    public fun mint(val: u64): Coins {
        let new_coin = Coins{ val }; å¦‚æœç»“æ„ä½“çš„æˆå‘˜åç§°ä¸å‡½æ•°å‚æ•°åç›¸åŒï¼Œå¯ç›´æ¥ä¼ é€’ï¼Œå¦åˆ™éœ€è¦å†™æˆ {æˆå‘˜å: å‚æ•°å}
        new_coin
    }

    /// If struct object does not have `drop` ability, it cannot be destroyed at the end of the script scope,
    /// and needs explicit desctructuring method.
    public fun burn(coin: Coins) {   
        let Coins{ val: _ } = coin; é”€æ¯ coin
    }

    /// Create `Balance` resource to account.
    /// In Move to store resource under account you have to provide user signature (`acc: &signer`).
    /// So before starting work with balances (use `deposit`, `withdraw`), account should add Balance resource
    /// on it's own account.
    public fun create_balance(acc: &signer) {
        let acc_addr = Signer::address_of(acc);

        assert!(!balance_exists(acc_addr), ERR_BALANCE_EXISTS);

        let zero_coins = Coins{ val: 0 };
        move_to(acc, Balance { coins: zero_coins}); æŠŠèµ„æºç»‘å®šåˆ° Account ä¸Š
    }

    /// Check if `Balance` resource exists on account.
    public fun balance_exists(acc_addr: address): bool {
        exists<Balance>(acc_addr)
    }

    /// Deposit coins to user's balance (to `acc` balance).
    public fun deposit(acc_addr: address, coin: Coins) acquires Balance {
        assert!(balance_exists(acc_addr), ERR_BALANCE_NOT_EXISTS);

        let Coins { val } = coin;   // è·å– coin ä¸­ val çš„å€¼
        let balance = borrow_global_mut<Balance>(acc_addr);
        balance.coins.val = balance.coins.val + val;
    }

    /// Withdraw coins from user's balance (withdraw from `acc` balance).
    public fun withdraw(acc: &signer, val: u64): Coins acquires Balance {
        let acc_addr = Signer::address_of(acc);
        assert!(balance_exists(acc_addr), ERR_BALANCE_NOT_EXISTS);

        let balance = borrow_global_mut<Balance>(acc_addr);
        balance.coins.val = balance.coins.val - val;
        Coins{ val }
    }

    /// Get balance of an account.
    public fun balance(acc_addr: address): u64 acquires Balance {
        borrow_global<Balance>(acc_addr).coins.val
    }
}

script {
    use Std::Signer;
    use Sender::Coins;

    // Mint new coins and deposit to account.
    fun mint_coin(acc: signer, amount: u64) {
        let acc_addr = Signer::address_of(&acc);
        let coins = Coins::mint(amount);

        if (!Coins::balance_exists(acc_addr)) {
            Coins::create_balance(&acc);
        };

        Coins::deposit(acc_addr, coins);
        assert!(Coins::balance(acc_addr) == amount, 1);
    }
}
æµ‹è¯• mint_coin(0x11, 100)
{% endhighlight %}

AptosCoin
{% highlight ruby %}
ä¾èµ– https://github.com/aptos-labs/aptos-core


/// The module to show how to create a new coin on Aptos network.
module Sender::AptosCoin {
    use Std::ASCII::string;
    use AptosFramework::Coin::Self;
    use Std::Signer;

    // Errors.

    /// When capability is missed on account.
    const ERR_CAP_MISSED: u64 = 100;

    /// When capability already exists on account.
    const ERR_CAP_EXISTS: u64 = 101;

    /// Represents new user coin.
    /// Indeeed this type will be used as CoinType for your new coin.
    struct MyCoin {}

    /// The struct to store capability: mint and burn.
    struct Capability<CapType: store> has key {
        cap: CapType
    }

    /// Initializing `MyCoin` as coin in Aptos network.
    public fun initialize_internal(account: &signer) {
        // Initialize `MyCoin` as coin type using Aptos Framework.
        let (mint_cap, burn_cap) = Coin::initialize<MyCoin>(
            account,
            string(b"MyCoin"),
            string(b"MC"),
            10,
            true,
        );

        // Store mint and burn capabilities under user account.
        move_to(account, Capability { cap: mint_cap });
        move_to(account, Capability { cap: burn_cap });
    }

    // public(script) ç›¸å½“äºè¿™æ˜¯ä¸€ä¸ªè„šæœ¬
    /// Similar to `initialize_internal` but can be executed as script.
    public(script) fun initialize(account: &signer) {
        initialize(account);
    }

    /// Extract mint or burn capability from user account.
    /// Returns extracted capability.
    public fun extract_capability<CapType: store>(account: &signer): CapType acquires Capability {
        let account_addr = Signer::address_of(account);

        // Check if capability stored under account.
        assert!(exists<Capability<CapType>>(account_addr), ERR_CAP_MISSED);

        // Get capability stored under account.
        let Capability { cap } =  move_from<Capability<CapType>>(account_addr);
        cap
    }

    /// Put mint or burn `capability` under user account.
    public fun put_capability<CapType: store>(account: &signer, capability: CapType) {
        let account_addr = Signer::address_of(account);

        // Check if capability doesn't exist under account so we can store.
        assert!(!exists<Capability<CapType>>(account_addr), ERR_CAP_EXISTS);

        // Store capability.
        move_to(account, Capability<CapType> {
            cap: capability
        });
    }
}
{% endhighlight %}


## 0x08 é¡¹ç›®å®æˆ˜
* çƒæ˜Ÿå¡ä¿¡æ¯
* åŠŸèƒ½
1. åˆ›å»º
2. ç©ºæŠ•
3. æŸ¥çœ‹
4. ä»·å€¼
5. è½¬è´¦ï¼ˆç»“åˆ Coinsï¼‰

{% highlight ruby %}
module 0x1::Football {


    // error code
    const STAR_ALREADY_EXISTS:u64 = 100;
    const STAR_NOT_EXISTS:u64 = 101;

    // qiuxing ka
    struct FootballStar has key {
        name: vector<u8>,
        country: vector<u8>,
        position: u8,
        value: u64,

    }
}
{% endhighlight %}
