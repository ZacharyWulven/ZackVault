---
layout: post
title: ### -2022-02-09-å¤šçº¿ç¨‹(äºŒ).markdown
date: 2022-02-09 11:00:30.000000000 +09:00
tag: OC åº•å±‚åŸç† å¤šçº¿ç¨‹
---

### å¤šçº¿ç¨‹è®¿é—®å®‰å…¨éšæ‚£
æ¯”å¦‚å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€å¯¹è±¡ï¼ŒåŒä¸€å˜é‡ï¼ŒåŒä¸€ä¸ªæ–‡ä»¶ï¼Œæœ€å¸¸è§å°±æ˜¯å–ç¥¨ã€å­˜/å–é’±çš„é—®é¢˜ã€‚è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨çº¿ç¨‹åŒæ­¥æŠ€æœ¯(åŒæ­¥ï¼ŒæŒ‰ç…§é¢„å®šçš„å…ˆåé¡ºåºè¿›è¡Œ)ã€‚
Â 
#### å¸¸ç”¨çº¿ç¨‹åŒæ­¥æŠ€æœ¯: åŠ é”ï¼ˆåŸç†ï¼šåˆ¤æ–­è¿™æŠŠé”æœ‰æ²¡æœ‰è¢«é”ï¼Œå¦‚æœè¢«é”å°±ç­‰å¾…ï¼‰ï¼Œé€ æˆçº¿ç¨‹é˜»å¡çš„æ•ˆæœï¼Œä¸€èˆ¬æœ‰ä¸¤ç§ï¼š
1. äº’æ–¥é”ï¼ˆä½çº§é”ï¼‰ï¼šè®©çº¿ç¨‹ä¼‘çœ ï¼Œå”¤é†’ä¹Ÿè€—è´¹æ€§èƒ½
2. è‡ªæ—‹é”ï¼ˆé«˜çº§é”ï¼‰ï¼šå¿™ç­‰ï¼Œä¸€ç›´å ç”¨ CPU èµ„æº, ç›¸å½“äºå†™äº† while(é”è¿˜æ²¡è¢«æ”¾å¼€) {}
Â  Â 
{% highlight ruby %}
å¤šä¸ªçº¿ç¨‹è¯»å–ä¸€ä¸ªå€¼ä¸éœ€è¦åŠ é”ï¼ŒåŒæ—¶æ”¹ä¸€ä¸ªä¸œè¥¿è¦åŠ é”ï¼Œå¤šä¸ªçº¿ç¨‹è¦ç”¨åŒä¸€æŠŠé”æ—¶ï¼Œéœ€è¦æŒæœ‰æˆæˆå‘˜å˜é‡ã€‚
{% endhighlight %}

### iOS é”
* OSSpinLock Â  è‡ªæ—‹é”ï¼ŒiOS 10 å¼€å§‹è¿‡æœŸäº†ï¼Œä¸å®‰å…¨äº†ï¼Œä¼šå‡ºç°ä¼˜å…ˆçº§åè½¬çš„é—®é¢˜ï¼Œå®˜æ–¹æ¨èä½¿ç”¨ os_unfair_loc æ›¿ä»£
* os_unfair_loc
* pthread_mutex
* dispatch_semaphore
* dispatch_queue(DISPATCH_QUEUE_SERIAL)
* NSLock
* NSRecursiveLock
* NSCondition
* NSConditionLock
* @synchronized
* å±æ€§ atomic


åº”ç”¨ä»£ç  Base ç±»ï¼Œæ¯ä¸€ä¸ªé”çš„åŸºç±»
{% highlight ruby %}
@interface BaseLockTest : NSObject
@property (nonatomic, assign) int ticket;
@property (nonatomic, assign) int money;

- (void)moneyOperation;
- (void)saleTickets;
- (void)saleTicket;
- (void)saveMoney;
- (void)drawMoney;
- (void)saleTicketsAssembly;
@end

@implementation BaseLockTest

- (void)saleTicket {
  NSInteger oldTicket = self.ticket;
  sleep(.2);
  oldTicket--;
  self.ticket = oldTicket;
  NSLog(@"è¿˜å‰© %ld å¼ ç¥¨ - %@", (long)self.ticket, [NSThread currentThread]);
}

- (void)saleTickets {
  self.ticket = 15;
  dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
  dispatch_async(queue, ^{
    for (int i = 0; i < 5; i++) {
         [self saleTicket];
    }
  });
  dispatch_async(queue, ^{
    for (int i = 0; i < 5; i++) {
         [self saleTicket];
    }
  });
  dispatch_async(queue, ^{
    for (int i = 0; i < 5; i++) {
         [self saleTicket];
    }
  });
}

- (void)drawMoney {
  int oldMoney = self.money;
  sleep(.2);
  oldMoney -= 20;
  self.money = oldMoney;
  NSLog(@"å–20ï¼Œè¿˜å‰©%då…ƒ - %@", self.money, [NSThread currentThread]);
}

- (void)saveMoney {
    int oldMoney = self.money;
    sleep(.2);
    oldMoney += 50;
    self.money = oldMoney;
    NSLog(@"å­˜50ï¼Œè¿˜å‰©%då…ƒ - %@", oldMoney, [NSThread currentThread]);
}

- (void)moneyOperation {
  self.money = 100;
  dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
  dispatch_async(queue, ^{
      for (int i = 0; i < 10; i++) {
          [self saveMoney];
      }
  });  
  dispatch_async(queue, ^{
      for (int i = 0; i < 10; i++) {
          [self drawMoney];
      }
  });
}

@end
{% endhighlight %}

#### OSSpinLock è‡ªæ—‹é”
ç­‰å¾…é”çš„çº¿ç¨‹ä¼šå¤„äºå¿™ç­‰ (busy-wait) çŠ¶æ€ï¼Œä¸€ç›´å ç”¨ç€ CPU èµ„æºï¼ŒiOS 10 å¼€å§‹è¿‡æœŸäº†ï¼Œä¸å®‰å…¨äº†ï¼Œä¼šå‡ºç°ä¼˜å…ˆçº§åè½¬çš„é—®é¢˜ã€‚
å³å¦‚æœç­‰å¾…é”çš„çº¿ç¨‹ä¼˜å…ˆçº§æ¯”è¾ƒé«˜ï¼Œå®ƒä¼šä¸€ç›´å ç”¨ CPU èµ„æºï¼Œä¼˜å…ˆçº§ä½çš„çº¿ç¨‹æ— æ³•é‡Šæ”¾é”ã€‚çº¿ç¨‹è°ƒåº¦ï¼Œç»™æ¯ä¸ªçº¿ç¨‹ä¸€æ®µæ—¶é—´æ‰§è¡Œä»»åŠ¡ï¼Œå¦‚æœç»™çš„æ‰§è¡Œæ—¶é—´æœ€åå°ï¼Œçœ‹ä¸Šå»åƒå¤šä¸ªçº¿ç¨‹åŒæ—¶èµ°ï¼Œæ—¶é—´ç‰‡è½®è½¬è°ƒåº¦ç®—æ³•(è¿›ç¨‹ã€çº¿ç¨‹)ï¼Œçº¿ç¨‹ä¼˜å…ˆçº§é«˜å°±ç»™è®©å…¶å¤šåšäº›äº‹ã€‚

ä¾‹å¦‚ç°æœ‰çº¿ç¨‹ 1/2ï¼Œä¸¤ä¸ªçº¿ç¨‹ï¼Œçº¿ç¨‹ 1 ä¼˜å…ˆçº§é«˜ï¼Œçº¿ç¨‹ 2 ä¼˜å…ˆçº§ä½ï¼Œå‡å¦‚çº¿ç¨‹ 2 å…ˆè¿›å…¥å‡½æ•°è¿›è¡Œäº†é”å®šï¼Œç„¶åçº¿ç¨‹ 1 è¿›å…¥å‡½æ•°ä½†ç”±äºè¢«çº¿ç¨‹ 2 é”äº†ï¼Œä¼šå¿™ç­‰ï¼Œé€ æˆ CPU å¤šåˆ†é…ä»»åŠ¡ç»™çº¿ç¨‹ 1 å¿™ç­‰ï¼Œå¯¼è‡´ CPU èµ„æºè€—å°½æ— æ³•åˆ†é…èµ„æºç»™çº¿ç¨‹ 2 ä»¥è¾¾åˆ°çº¿ç¨‹ 2 çš„è§£é”é‡Šæ”¾ã€‚

åº”ç”¨éœ€è¦å¯¼å…¥å¤´æ–‡ä»¶ #import <libkern/OSAtomic.h>
{% highlight ruby %}
@implementation OSSpinLockTest {
  OSSpinLock _lock;
}

- (instancetype)init {
  self = [super init];
  if (self) {
      _lock = OS_SPINLOCK_INIT;
  }
  return self;
}

- (void)saleTicket {
    if (OSSpinLockTry(&_lock)) {
  //    NSInteger oldTicket = self.ticket;
  //    //ç¡çœ æ—¶é—´è¶Šå¤§å®‰å…¨éšæ‚£è¶Šæ˜æ˜¾
  //    sleep(0.2);
  //    oldTicket--;
  //    self.ticket = oldTicket;
  //    OSSpinLockUnlock(&_lock1);
  //  }
  static OSSpinLock _lock1 = OS_SPINLOCK_INIT;

  OSSpinLockLock(&_lock1);
  [super saleTicket];
  OSSpinLockUnlock(&_lock1);
}

- (void)saveMoney {
  OSSpinLockLock(&_lock);
  [super saveMoney];
  OSSpinLockUnlock(&_lock);
}

- (void)drawMoney {
  OSSpinLockLock(&_lock);
  [super drawMoney];
  OSSpinLockUnlock(&_lock);
}

@end
{% endhighlight %}

#### os_unfair_lock(äº’æ–¥é”) 
æ˜¯ OSSpinLock çš„æ›¿ä»£æ–¹æ¡ˆï¼ŒiOS10 åŠä»¥ä¸Šå¯ç”¨ï¼Œä»åº•å±‚çœ‹ç­‰å¾… os_unfair_lock é”çš„çº¿ç¨‹ä¼šå¤„äºä¼‘çœ çŠ¶æ€ï¼Œè€Œéå¿™ç­‰

åº”ç”¨éœ€è¦å¯¼å…¥å¤´æ–‡ä»¶ #import <os/lock.h>
{% highlight ruby %}
@implementation OSUnfairLlockTest {
  os_unfair_lock lock; //æ˜¯ä¸ªç»“æ„ä½“
  os_unfair_lock lock1; //æ˜¯ä¸ªç»“æ„ä½“
}

- (instancetype)init {
  self = [super init];
  if (self) {
    lock = OS_UNFAIR_LOCK_INIT;
    lock1 = OS_UNFAIR_LOCK_INIT;
  }
  return self;
}
- (void)saleTicket {
  os_unfair_lock_lock(&lock1);
  [super saleTicket];
  os_unfair_lock_unlock(&lock1);
}

- (void)saveMoney {
  os_unfair_lock_lock(&lock);
  [super saveMoney];
  os_unfair_lock_unlock(&lock);
}

- (void)drawMoney {
  os_unfair_lock_lock(&lock);
  [super drawMoney];
  os_unfair_lock_unlock(&lock);
}

@end
{% endhighlight %}

#### pthread_mutex 
p å¼€å¤´éƒ½æ˜¯æ‰©å¹³å°çš„é€šç”¨çš„ã€‚äº’æ–¥é”(ç­‰å¾…çš„çº¿ç¨‹ä¼šå¤„äºä¼‘çœ çŠ¶æ€)ã€‚

åº”ç”¨éœ€è¦å¯¼å…¥å¤´æ–‡ä»¶ #import <pthread.h>

* pthread_mutex æ™®é€šé”
{% highlight ruby %}
@implementation PthreadMutexLockTest {
  pthread_mutex_t _mutex; // struct
  pthread_mutex_t _mutex1; // struct
}

- (void)__initMutex:(pthread_mutex_t *)mutex {
      // é™æ€åˆå§‹åŒ–ï¼Œstructè¯­æ³•å®šä¹‰æ—¶å€™å¯ä»¥åˆå§‹åŒ–
      // pthread_mutex_t_mutex = PTHREAD_MUTEX_INITIALIZER;
      // pthread_mutex_t _mutex1 = PTHREAD_MUTEX_INITIALIZER;
      
      //åˆå§‹åŒ–å±æ€§
      pthread_mutexattr_t attr;
      pthread_mutexattr_init(&attr);
      pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);
      
      //åˆå§‹åŒ–é”
      pthread_mutex_init(mutex, &attr);
      // pthread_mutex_init(mutex, NULL); attr ä¼  NULL å°±æ˜¯ PTHREAD_MUTEX_DEFAULT

      //é”€æ¯å±æ€§
      pthread_mutexattr_destroy(&attr);
}

- (instancetype)init {
  self = [super init];
  if (self) {
    [self __initMutex:&_mutex];
    [self __initMutex:&_mutex1];
  }
  return self;
}

- (void)dealloc {
  pthread_mutex_destroy(&_mutex1);
  pthread_mutex_destroy(&_mutex);
}

- (void)saleTicket {
  pthread_mutex_lock(&_mutex1);
  [super saleTicket];
  pthread_mutex_unlock(&_mutex1);
}

- (void)saveMoney {
  pthread_mutex_lock(&_mutex);
  [super saveMoney];
  pthread_mutex_unlock(&_mutex);
}

- (void)drawMoney {
  pthread_mutex_lock(&_mutex);
  [super drawMoney];
  pthread_mutex_unlock(&_mutex);
}

@end
{% endhighlight %}

* pthread_mutex é€’å½’é”

å‡å¦‚ test1 é‡Œè°ƒç”¨äº† test2ï¼Œè¿™æ—¶ä¼šå‡ºç°æ­»é”ï¼Œè§£å†³æ–¹å¼æ˜¯ test2 æ¢ä¸€æŠŠé”ã€‚
{% highlight ruby %}
- (void)test1 {  
  pthread_mutex_lock(&_mutex);
  [self recursiveTest2];
  pthread_mutex_unlock(&_mutex);
}

- (void)test2 {
  pthread_mutex_lock(&_mutex);
  NSLog(@"%s", __func__);
  pthread_mutex_unlock(&_mutex);
}
{% endhighlight %}

ä½†å¦‚æœ test1 é‡Œé€’å½’è°ƒç”¨äº† test1ï¼Œåˆ™éœ€è¦æ¢æˆé€’å½’é”ï¼Œå³åˆå§‹åŒ–æ—¶ pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE)ã€‚
{% highlight ruby %}
- (void)__initMutex:(pthread_mutex_t *)mutex {
      //åˆå§‹åŒ–å±æ€§
      pthread_mutexattr_t attr;
      pthread_mutexattr_init(&attr);
      pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
      
      //åˆå§‹åŒ–é”
      pthread_mutex_init(mutex, &attr);
      // pthread_mutex_init(mutex, NULL);

      //é”€æ¯å±æ€§
      pthread_mutexattr_destroy(&attr);
}

- (void)recursiveTest {
  pthread_mutex_lock(&_mutex);
  static int count = 0;
  NSLog(@"%s", __func__);
  count++;
  if (count < 10) {
    [self recursiveTest];
  } else {
    NSLog(@"recursiveTest end");
  }
  pthread_mutex_unlock(&_mutex);
}
{% endhighlight %}

* pthread_mutex & cond æ¡ä»¶é”

é€‚ç”¨äºç”Ÿäº§è€…/æ¶ˆè´¹è€…æ¨¡å¼ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªçº¿ç¨‹ä¾èµ–å¦ä¸€ä¸ªçº¿ç¨‹åšå®Œå†å›åˆ°è‡ªå·±åšä¸€äº›äº‹ã€‚å‡å¦‚ç”Ÿäº§æ¶ˆè´¹ï¼Œæ¶ˆè´¹æ—¶å¿…é¡»ä¿è¯åº“å­˜é‡Œæœ‰ä¸œè¥¿ï¼Œå³ç”Ÿäº§äº†ä¸œè¥¿æ‰èƒ½æ¶ˆè´¹ã€‚

{% highlight ruby %}
@implementation PthreadMutexConditionLockTest {
  pthread_mutex_t _mutex; // struct
  NSMutableArray<NSString *> *_feed;
  pthread_cond_t _condition;
}

- (void)__initMutex:(pthread_mutex_t *)mutex {
      //åˆå§‹åŒ–å±æ€§
      pthread_mutexattr_t attr;
      pthread_mutexattr_init(&attr);
      pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
      
      //åˆå§‹åŒ–æ¡ä»¶
      pthread_cond_init(&_condition, NULL);
  
      //åˆå§‹åŒ–é”
      pthread_mutex_init(mutex, &attr);
      
      //é”€æ¯å±æ€§
      pthread_mutexattr_destroy(&attr);
}

- (instancetype)init {
  self = [super init];
  if (self) {
    [self __initMutex:&_mutex];
    _feed = [NSMutableArray array];
  }
  return self;
}

- (void)dealloc {
  pthread_mutex_destroy(&_mutex);
  pthread_cond_destroy(&_condition);
}

- (void)conditionTest {
  int n  = 10;
  while (n > 0) {
    [[[NSThread alloc] initWithTarget:self selector:@selector(__consumer) object:nil] start];    
//    sleep(2);
    [[[NSThread alloc] initWithTarget:self selector:@selector(__produce) object:nil] start];
    n--;
  }
}
// çº¿ç¨‹ä¸€
- (void)__consumer {
  NSLog(@"%s", __func__);

  pthread_mutex_lock(&_mutex);
  if (_feed.count == 0) {
    //ç­‰å¾…ï¼Œç›¸å½“äºä¼‘çœ ï¼Œè¿™ä¸ªæ—¶å€™ä¼šè§£é”
    //è¢«å”¤é†’å åˆåŠ é”äº†
    pthread_cond_wait(&_condition, &_mutex);
  }
  [_feed removeLastObject];
  NSLog(@"remove object");
  pthread_mutex_unlock(&_mutex);
}
// çº¿ç¨‹äºŒ
- (void)__produce {
  NSLog(@"%s", __func__);

  static int count = 0;
  pthread_mutex_lock(&_mutex);
  NSString *obj = [NSString stringWithFormat:@"text_%d", count++];
  [_feed addObject:obj];
  NSLog(@"add object");

  //ä¿¡å·: å”¤é†’ pthread_cond_wait ä½¿å…¶å¾€ä¸‹èµ°ï¼Œæ¿€æ´»ä¸€ä¸ªç­‰å¾…è¿™ä¸ªæ¡ä»¶çš„çº¿ç¨‹
  pthread_cond_signal(&_condition);
  //å¹¿æ’­: æ¿€æ´»æ‰€æœ‰ç­‰å¾…è¿™ä¸ªæ¡ä»¶çš„çº¿ç¨‹
  // pthread_cond_broadcast(&_condition);
  
  pthread_mutex_unlock(&_mutex);
}

@end
{% endhighlight %}

#### NSLock
å³å¯¹ mutex æ™®é€šé”çš„å°è£…ã€‚

{% highlight ruby %}
ç±»ä¼¼
pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
pthread_mutex_init(mutex, &attr); // OR pthread_mutex_init(mutex, NULL)

- (BOOL)lockBeforeDate:(NSDate *)limit; // åœ¨è¿™ä¸ªæ—¶é—´å‰ç­‰ä¸åˆ°é”å°±ç¡è§‰ï¼Œç­‰åˆ°äº†å°±åŠ é”æˆåŠŸè¿”å› yes
{% endhighlight %}

#### NSRecursiveLock
çœ‹ GNU æºç  NSRecursiveLock åˆ™æ˜¯å¯¹ pthread_mutex PTHREAD_MUTEX_RECURSIVE çš„å°è£…ã€‚API åŒ NSLockã€‚

#### NSCondition
å³å¯¹ mutex & cond çš„å°è£…ã€‚Â 

#### NSConditionLock 
å³å¯¹ NSCondition çš„å°è£…ã€‚ç”¨æ³•å¯ä»¥è®©çº¿ç¨‹ä¹‹é—´çš„ä¾èµ–ï¼Œè®©å¤šçº¿ç¨‹å˜ä¸²è¡Œã€‚

{% highlight ruby %}
@implementation ConditionLockLockTest {
  NSConditionLock *_conditionLock;
  NSMutableArray *_feed;
}

- (instancetype)init {
  self = [super init];
  if (self) {
    _feed = [NSMutableArray array];
    _conditionLock = [[NSConditionLock alloc] initWithCondition:1]; // æ¡ä»¶å€¼ é»˜è®¤æ˜¯ 0
  }
  return self;
}

- (void)conditionTest {
  [[[NSThread alloc] initWithTarget:self selector:@selector(__three) object:nil] start];
  [[[NSThread alloc] initWithTarget:self selector:@selector(__one) object:nil] start];
  [[[NSThread alloc] initWithTarget:self selector:@selector(__two) object:nil] start];
}

- (void)__one {
  // å½“æ¡ä»¶å€¼ä¸º 1 æ—¶å€™æ‰åŠ é”ï¼Œå¦åˆ™åœ¨è¿™é‡Œç­‰å¾…
  [_conditionLock lockWhenCondition:1];

//  [_conditionLock lock]; ç›´æ¥åŠ é”ä¸ç®¡æ¡ä»¶å€¼

  NSLog(@"%s", __func__);
  sleep(1);
  //æŠŠé”æ”¾å¼€ï¼Œå¹¶æŠŠæ¡ä»¶å€¼è®¾ç½®ä¸º2
  [_conditionLock unlockWithCondition:2];
}

- (void)__two {
  [_conditionLock lockWhenCondition:2];

  NSLog(@"%s", __func__);
  sleep(1);
  [_conditionLock unlockWithCondition:3];
}

- (void)__three {
  [_conditionLock lockWhenCondition:3];
  NSLog(@"%s", __func__);
  sleep(1);
  [_conditionLock unlock];
}

@endÂ Â  Â  

ä¾æ¬¡æ‰§è¡Œ __one __two __three
{% endhighlight %}

#### dispatch_semaphore ä¿¡å·é‡
ä¿¡å·é‡å¯ä»¥ç”¨æ¥æ§åˆ¶çº¿ç¨‹å¹¶å‘è®¿é—®çš„æœ€å¤§æ•°é‡ã€‚

{% highlight ruby %}
// åªæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨å·¥ä½œï¼Œå³çº¿ç¨‹æœ€å¤§å¹¶å‘æ•°ä¸º 1
_semaphore = dispatch_semaphore_create(1) 

- (void)__test {
  // å¦‚æœä¿¡å·é‡çš„å€¼ > 0ï¼Œå°±è®©ä¿¡å·é‡å€¼å‡1ï¼Œç„¶åç»§ç»­æ‰§è¡Œ
  // å¦‚æœä¿¡å·é‡çš„å€¼ <= 0ï¼Œå°±ä¼šä¼‘çœ ç­‰å¾…ï¼Œç›´åˆ°ä¿¡å·é‡å€¼ > 0ï¼Œå°±è®©ä¿¡å·é‡å‡ 1ï¼Œç„¶åç»§ç»­å¾€ä¸‹æ‰§è¡Œ
  // DISPATCH_TIME_FOREVER è¡¨ç¤ºä¸€ç›´ç­‰ï¼ŒDISPATCH_TIME_NOW å°±é©¬ä¸Šçœ‹èƒ½ä¸èƒ½ç­‰åˆ°è§£é”ï¼Œä¸èƒ½å°±å¤±è´¥
  dispatch_semaphore_wait(_semaphore3, DISPATCH_TIME_FOREVER);

  sleep(1);
  NSLog(@"test -- %@", [NSThread currentThread]);
  // è®©ä¿¡å·é‡çš„å€¼ +1
  dispatch_semaphore_signal(_semaphore3);
}
{% endhighlight %}

#### @synchronized é€’å½’é”
@synchronized (object) æºç æ˜¯å¯¹ mutex é€’å½’é”çš„å°è£…ï¼Œæ€§èƒ½å¾ˆå·®ï¼Œä¸æ¨èä½¿ç”¨ã€‚æ±‡ç¼–å¯è§‚å¯Ÿåˆ°ä¼šè°ƒç”¨ objc_sync_enter è¿›å…¥ã€‚
Â Â 
objc æºç Â Â  
{% highlight ruby %}
int objc_sync_enter(id obj) {
  int result = OBJC_SYNC_SUCCESS;

  if (obj) {
      SyncData* data = id2data(obj, ACQUIRE);
      ASSERT(data);
      data->mutex.lock();
  } else {
      // @synchronized(nil) does nothing
      if (DebugNilSync) {
          _objc_inform("NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug");
      }
      objc_sync_nil();
  }

  return result;
}

typedef struct alignas(CacheLineSize) SyncData {
    struct SyncData* nextData;
    DisguisedPtr<objc_object> object;
    int32_t threadCount;  // number of THREADS using this block
    recursive_mutex_t mutex;   // é€’å½’é”
} SyncData;


å¯ä»¥ç†è§£ä¸º
@synchronized (self) {
// æ ¹æ® self æ‰¾åˆ°ä¸€ä¸ªæŠŠé”ï¼Œå¯ä»¥ä¼ åˆ«çš„å¯¹è±¡
Â Â  Code...
}
ä¿è¯æ¯ä¸ªå®ä¾‹å¯¹è±¡éƒ½ç”¨åŒä¸€æŠŠé”ï¼Œç”¨ [self class]
@synchronized ([self class]) {

}
{% endhighlight %}
åº•å±‚å®ç°ä½¿ç”¨å“ˆå¸Œè¡¨ç»“æ„ç”¨ä¼ å…¥ object ä½œä¸º keyï¼Œæ‰¾åˆ°å¯¹åº”çš„ valueï¼ˆlockï¼‰ã€‚

{% highlight ruby %}
- (void)saveMoney {
  // self is a lock
  @synchronized (self) { //objc_sync_enter
    [super saveMoney];
  } //objc_sync_exit
}

- (void)drawMoney {
  @synchronized (self) {
    [super drawMoney];
  }
}
{% endhighlight %}

### å„æ–¹æ¡ˆæ€§èƒ½ä»é«˜åˆ°ä½å¯¹æ¯”ï¼Œä»…ä¾›å‚è€ƒ ğŸ˜
* os_unfair_loc          // ä¹Ÿå¯æ¨èï¼Œä½†è¦çœ‹ä¸‹ iOS ç‰ˆæœ¬
* OSSpinLock           
* dispatch_semaphore     // æ¨è
* pthread_mutex          // æ¨è
* dispatch_queue(DISPATCH_QUEUE_SERIAL)
* NSLock
* NSCondition
* pthread_mutex(recursive)
* NSRecursiveLock
* NSConditionLock
* @synchronized

### æ±‡ç¼–åˆ†æ
* lldb continue ç»§ç»­æ–­ç‚¹ï¼Œå…è®¸ç¨‹åºæ­£å¸¸æ‰§è¡Œ (è¦ä¹ˆä¸€ç›´æ‰§è¡Œä¸‹å»ï¼Œè¦ä¹ˆåˆ°è¾¾ä¸‹ä¸€ä¸ªæ–­ç‚¹)ã€‚åœ¨ LLDB ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨Â process continueÂ å‘½ä»¤æ¥è¾¾åˆ°åŒæ ·çš„æ•ˆæœï¼Œå®ƒçš„åˆ«åä¸ºÂ continueï¼Œæˆ–è€…ä¹Ÿå¯ä»¥ç¼©å†™ä¸ºÂ cã€‚

* lldb next ä¸€è¡Œä¸€è¡Œèµ°ï¼Œé‡åˆ°å‡½æ•°ä¼šä¸€ç¬”å¸¦è¿‡ï¼Œstep over æŒ‰é’®ï¼Œä¼šä»¥é»‘ç›’çš„æ–¹å¼æ‰§è¡Œä¸€è¡Œä»£ç ã€‚å¦‚æœæ‰€åœ¨è¿™è¡Œä»£ç æ˜¯ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œé‚£ä¹ˆå°±ä¸ä¼šè·³è¿›è¿™ä¸ªå‡½æ•°ï¼Œè€Œæ˜¯ä¼šæ‰§è¡Œè¿™ä¸ªå‡½æ•°ï¼Œç„¶åç»§ç»­ã€‚LLDB åˆ™å¯ä»¥ä½¿ç”¨Â thread step-overï¼Œnextï¼Œæˆ–è€…Â nÂ å‘½ä»¤

* lldb s å¦‚æœä½ ç¡®å®æƒ³è·³è¿›ä¸€ä¸ªå‡½æ•°è°ƒç”¨æ¥è°ƒè¯•æˆ–è€…æ£€æŸ¥ç¨‹åºçš„æ‰§è¡Œæƒ…å†µï¼Œstep inï¼Œæˆ–è€…åœ¨ LLDB ä¸­ä½¿ç”¨Â thread step inï¼Œstepï¼Œæˆ–è€…Â sÂ å‘½ä»¤ã€‚æ³¨æ„ï¼Œå½“å‰è¡Œä¸æ˜¯å‡½æ•°è°ƒç”¨æ—¶ï¼ŒnextÂ å’ŒÂ stepÂ æ•ˆæœæ˜¯ä¸€æ ·çš„ã€‚

* step å¯¹åº”ä¸€è¡Œä»£ç ï¼ˆä»£ç çº§åˆ«ï¼‰ï¼Œä¸€æ®µ OC ä»£ç ç›¸å½“äºè‹¥å¹²è¡Œæ±‡ç¼–ä»£ç ã€‚æƒ³çœ‹ä¸€è¡Œä¸€è¡Œæ±‡ç¼–ç”¨ si

* lldb si æ±‡ç¼–ä¸€è¡Œä¸€è¡Œèµ°ï¼Œå¦‚æœè¦è¿›å…¥å‡½æ•°ç”¨ si

* j è·³è½¬

* ne ä¸€ä¸ªæ¡ä»¶

* jne å¦‚æœæ¡ä»¶ç¬¦åˆè·³è½¬


#### OSSpinLock è‡ªæ—‹é”æ±‡ç¼–è°ƒç”¨
{% highlight ruby %}
libsystem_platform.dylib`_OSSpinLockLockSlow:
    0x7fff6bfe1261 <+0>:  pushq  %rbp
    0x7fff6bfe1262 <+1>:  movq   %rsp, %rbp
    0x7fff6bfe1265 <+4>:  movl   $0xfffffc18, %ecx         ; imm = 0xFFFFFC18 
    0x7fff6bfe126a <+9>:  movl   $0xffffffff, %edx         ; imm = 0xFFFFFFFF 
->  0x7fff6bfe126f <+14>: movl   (%rdi), %eax
    0x7fff6bfe1271 <+16>: testl  %eax, %eax
    0x7fff6bfe1273 <+18>: jne    0x7fff6bfe127d            ; <+28>
    0x7fff6bfe1275 <+20>: xorl   %eax, %eax
    0x7fff6bfe1277 <+22>: lock   
    0x7fff6bfe1278 <+23>: cmpxchgl %edx, (%rdi)
    0x7fff6bfe127b <+26>: je     0x7fff6bfe128c            ; <+43>
    0x7fff6bfe127d <+28>: cmpl   $-0x1, %eax
    0x7fff6bfe1280 <+31>: jne    0x7fff6bfe1294            ; <+51>
    0x7fff6bfe1282 <+33>: testl  %ecx, %ecx
    0x7fff6bfe1284 <+35>: je     0x7fff6bfe128e            ; <+45>
    0x7fff6bfe1286 <+37>: pause  
    0x7fff6bfe1288 <+39>: incl   %ecx
    0x7fff6bfe128a <+41>: jmp    0x7fff6bfe126f            ; <+14> å¯çœ‹åˆ°åˆè·³å› 0x7fff6bfe126f
    0x7fff6bfe128c <+43>: popq   %rbp
    0x7fff6bfe128d <+44>: retq   
{% endhighlight %}
ä¸Šè¾¹æ±‡ç¼–åˆå›åˆ° 0x7fff6bfe126f è¯´æ˜è¿™æ˜¯ä¸€ä¸ª while å¾ªç¯ã€‚æ‰€ä»¥ OSSpinLock å®ƒæ˜¯è‡ªæ—‹é”ã€‚

#### pthread_mutex äº’æ–¥é”æ±‡ç¼–è°ƒç”¨
{% highlight ruby %}
libsystem_kernel.dylib`__psynch_mutexwait:
    0x7fff6bf9a4c0 <+0>:  movl   $0x200012d, %eax          ; imm = 0x200012D 
->  0x7fff6bf9a4c5 <+5>:  movq   %rcx, %r10
    0x7fff6bf9a4c8 <+8>:  syscall                          è¿™é‡Œè°ƒç”¨äº† syscall ä¼‘çœ ï¼Œæ‰€ä»¥æ˜¯äº’æ–¥é”
    0x7fff6bf9a4ca <+10>: jae    0x7fff6bf9a4d4            ; <+20>
    0x7fff6bf9a4cc <+12>: movq   %rax, %rdi
    0x7fff6bf9a4cf <+15>: jmp    0x7fff6bf98ad9            ; cerror_nocancel
    0x7fff6bf9a4d4 <+20>: retq   
{% endhighlight %}
os_unfair_lock æœ€ç»ˆä¹Ÿä¼šè°ƒç”¨ syscall

### è‡ªæ—‹é” VS äº’æ–¥é”
ç”¨è‡ªæ—‹é”æ¯”è¾ƒåˆ’ç®—
* é¢„è®¡çº¿ç¨‹ç­‰å¾…é”æ—¶é—´çŸ­
* åŠ é”ä»£ç ï¼ˆä¸´ç•ŒåŒºï¼‰ç»å¸¸è¢«è°ƒç”¨ï¼Œä½†ç«äº‰æƒ…å†µå¾ˆå°‘å‘ç”Ÿ
* CPU èµ„æºéƒ¨ç´§å¼ 

ç”¨äº’æ–¥é”æ¯”è¾ƒåˆ’ç®—
* é¢„è®¡çº¿ç¨‹ç­‰å¾…é”æ—¶é—´é•¿
* å•æ ¸å¤„ç†å™¨
* ä¸´ç•ŒåŒºæœ‰ I/O æ“ä½œï¼Œå› ä¸º I/O å ç”¨ CPU
* ä¸´ç•ŒåŒºä»£ç æ¯”è¾ƒå¤æ‚æˆ–å¾ªç¯é‡å¤§
* ä¸´ç•ŒåŒºç«äº‰æ¿€çƒˆ

Tipsï¼š
{% highlight ruby %}
åŠ é”åè¦æ³¨æ„è§£é”ï¼Œè‹¥æ²¡æœ‰è§£é”ä¼šé€ æˆæ°¸è¿œè·å–ä¸åˆ°é”ï¼Œå³æ­»é”ã€‚
{% endhighlight %}
