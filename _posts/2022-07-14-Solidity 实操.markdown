---
layout: post
title: Solidity å®æ“
date: 2022-07-14 16:45:30.000000000 +09:00
tag: åŒºå—é“¾
---

## 0x01 æ™ºèƒ½åˆçº¦è®¾è®¡æ–¹å¼
1. è§’è‰²åˆ†æ
* è°ƒç”¨æ—¶å€™éƒ½æœ‰å“ªäº›äººè°ƒç”¨
2. è§’è‰²åŠŸèƒ½åˆ†æ

### ä»¥æ‹å–åˆçº¦ä¸ºä¾‹
è§’è‰²åˆ†æ
1. å¹³å°æ–¹
* åˆ›å»ºæ‹å–
* ç»“æŸæ‹å–
2. ä¹°æ–¹
* ç«æ‹ï¼ˆä»·é«˜è€…å¾—ï¼‰
3. å–æ–¹
* ç­‰å¾…ç»“æœ

## 0x02 ERC æ ‡å‡† 
ERC ä¹‹äºä»¥å¤ªåŠç›¸å½“äº RFC ä¹‹äºäº’è”ç½‘ã€‚å¯è§ ERC ç›¸å½“é‡è¦ã€‚

{% highlight ruby %}
https://eips.ethereum.org/erc
{% endhighlight %}

æ¯”è¾ƒé‡è¦çš„ä¾‹å¦‚ ERC-20ï¼Œå…è®¸é¡¹ç›®æ–¹å¯ä»¥åœ¨ä»¥å¤ªåŠå‘è¡Œè‡ªå·±çš„ä»£å¸å¹¶å‘èµ·ä¼—ç­¹ ICOï¼Œåœ¨æˆ‘å›½ ICO æ˜¯è¿æ³•çš„ğŸ˜‚ğŸ¤£ğŸ˜…ï¼Œ
ä½† ICO æ¨åŠ¨äº†ä»¥å¤ªåŠçš„å‘å±•ã€‚ç”±äºäº§ç”Ÿäº†ä¸€äº›å‰²éŸ­èœçš„æ¡ˆä¾‹ï¼Œæ‰€ä»¥æˆ‘å›½ 2017 å¹´å®£å¸ƒå…¶ä¸ºè¿æ³•ã€‚


## ERC-20 åŒè´¨åŒ– Token æ ‡å‡†
1. function name() public view returns (string) ä»£å¸åç§°ï¼Œå¯é€‰
2. function symbol() public view returns (string) ä»£å¸ç¬¦å·ï¼Œå¯é€‰
3. function decimals() public view returns (uint8) 
* å¯é€‰ï¼Œå°æ•°ç‚¹åå¤šå°‘ä½ï¼Œå®ç°è¡¨ç¤ºä»£å¸å¯åˆ†å‰²ï¼Œå†™ 8 ä»£è¡¨å°æ•°ç‚¹å 8 ä½ï¼Œå³ä¸€ä¸ªæ•°ä¹˜ä»¥ 10^8 ç­‰äºæœ€ç»ˆçš„æ•°é‡
4. function totalSupply() public view returns (uint256) æ€»å‘è¡Œé‡
5. function balanceOf(address _owner) public view returns (uint256 balance)
* è¿™ä¸ªæ™ºèƒ½åˆçº¦é‡Œè¾¹ Token çš„ä½™é¢
6. function transfer(address _to, uint256 _value) public returns (bool success)
* è°è½¬çš„å³ msg.sender
* é’ˆå¯¹ Token çš„è½¬è´¦
7. function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)
* æˆæƒï¼šfrom æˆæƒç»™ to èƒ½å¤Ÿè½¬å¤šå°‘
8. function approve(address _spender, uint256 _value) public returns (bool success)
* æˆæƒç»™ _spenderï¼Œä¸ transferFrom æ˜¯ä¸€å¯¹ï¼Œåªæœ‰ approve åæ‰èƒ½ transferFrom
9. function allowance(address _owner, address _spender) public view returns (uint256 remaining)
* æˆæƒé¢åº¦çš„æŸ¥è¯¢ï¼Œæˆæƒé¢åº¦æ¶ˆè€—äº†å°±åº”è¯¥æ¸…é›¶


IERC20.sol
{% highlight ruby %}
// SPDX-License-Identifier:Apache-2.0
pragma solidity^0.8.0;

interface IERC20 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);

    function totalSupply() external view returns (uint256);
    function balanceOf(address _owner) external view returns (uint256 balance);
    function transfer(address _to, uint256 _value) external returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
    function approve(address _spender, uint256 _value) external returns (bool success);
    function allowance(address _owner, address _spender) external view returns (uint256 remaining);
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);   

}
{% endhighlight %}

mytoken.sol
{% highlight ruby %}

// SPDX-License-Identifier:Apache-2.0
pragma solidity^0.8.0;

import "./17-IERC-20.sol";
import "./SafeMath.sol";

/*
    è§£å†³ token å‘è¡Œçš„é—®é¢˜ï¼Œé€šå¸¸ä¸¤ä¸ªæ–¹æ³•
    1 è®¾ç½® owner ç®¡ç†å‘˜ï¼Œé€šè¿‡ç®¡ç†å‘˜è´¦æˆ·å‘é’±
    2 æä¾› mint å‡½æ•°

*/

contract mytoken is IERC20 {
    // é’ˆå¯¹æ‰€æœ‰çš„ uint256 ç±»å‹ä½¿ç”¨ SafeMath åº“
    using SafeMath for uint256;

    // å®šä¹‰ name
    string tokenName;
    string tokenSymbol;
    uint256 tokenTotalSupply;

    address owner;  // ç®¡ç†å‘˜åœ°å€ï¼Œè§£å†³ token å‘è¡Œçš„é—®é¢˜

    // user's balance
    mapping(address=>uint256) _balances;
    // A->B 100, A æˆæƒç»™ B 100
    // A->C 200, A æˆæƒç»™ C 100
    mapping(address=>mapping(address=>uint256)) allows;


    constructor(string memory n, string memory s) public {
        tokenName = n;
        tokenSymbol = s;
        owner = msg.sender;
    }


    function mint(address _to, uint256 _value) external returns (bool success) {
        require(_value > 0, "_value must > 0");
        require(address(0) != _to, "to must a valid address");
        require(msg.sender == owner, "only owner can do it!");

        // _balances[_to] += _value;  // è¿™é‡Œå¯èƒ½ä¼šæº¢å‡º
        // use SafeMath åº“ è¿›è¡ŒåŠ æ³•
        _balances[_to] = _balances[_to].add(_value);

        tokenTotalSupply = tokenTotalSupply.add(_value);
        // æŒ–çŸ¿é€šçŸ¥ï¼Œfrom çš„åœ°å€æ˜¯ 0
        emit Transfer(address(0), _to, _value);
        success = true; 

    }

    // implement IERC20 interface
    function name() override external view returns (string memory) {
        return tokenName;
    }

    function symbol() override external view returns (string memory) {
        return tokenSymbol;
    }

    function totalSupply() override external view returns (uint256) {
        return tokenTotalSupply;
    }

    function balanceOf(address _owner) override external view returns (uint256 balance) {
        return _balances[_owner];
    }
    function transfer(address _to, uint256 _value) override external returns (bool success) {
        require(_value > 0, "_value must > 0");
        require(address(0) != _to, "to must a valid address");
        require(_balances[msg.sender] >= _value, "user's balance must enough");

        _balances[msg.sender]  = _balances[msg.sender].sub(_value);
        _balances[_to] =  _balances[_to].add(_value);

        // äº‹ä»¶é€šçŸ¥
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    // æˆæƒè½¬è´¦ï¼ŒåŠ¨ç”¨ _from çš„é’±, msg.sender å°±æ˜¯ _spender
    function transferFrom(address _from, address _to, uint256 _value) override external returns (bool success) {
        success = false;
        require(_value > 0, "_value must > 0");
        require(address(0) != _to, "to must a valid address");
        require(_balances[_from] >= _value, "user's balance must enough");

        _balances[_from] = _balances[_from].sub(_value);
        _balances[_to] = _balances[_to].add(_value);
        allows[_from][msg.sender] = allows[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);
        success = true;

    }

    function approve(address _spender, uint256 _value) override external returns (bool success) {
        success = false;
        require(_value > 0, "_value must > 0");
        require(address(0) != _spender, "to must a valid address");
        require(_balances[msg.sender] >= _value, "user's balance must enough");

        allows[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        success = true;
    //    return

    }

    function allowance(address _owner, address _spender) override external view returns (uint256 remaining) {
        return allows[_owner][_spender];
    }
    
    // event ç›´æ¥ç»§æ‰¿
    // event Transfer(address indexed _from, address indexed _to, uint256 _value);
    // event Approval(address indexed _owner, address indexed _spender, uint256 _value);   

}

{% endhighlight %}


## ERC-721 éåŒè´¨åŒ– Token æ ‡å‡†
1. ERC-721 å¿…é¡»åŒ…å« ERC-165 æ ‡å‡†ï¼ŒERC-165ç”¨äºè§£é‡Šè¯´æ˜æ˜¯å¦æŠŠæ¥å£è¯¥å®ç°çš„éƒ½å®ç°äº†
2. ApprovalForAll æˆæƒç®¡ç†å…¨éƒ¨ token
3. balanceOf å®é™…æ„ä¹‰ä¸å¤§ï¼Œå³æŸ¥è¯¢æœ‰å¤šå°‘ä¸ª token
4. ownerOf æŸ¥è¯¢ tokenId çš„å½’å±
5. safeTransferFrom å®‰å…¨è½¬è´¦
* to å¦‚æœæ˜¯æ™®é€šåœ°å€ï¼Œæ­£å¸¸è½¬è´¦
* to å¦‚æœæ˜¯åˆçº¦åœ°å€ï¼Œåˆ™ to è¿™ä¸ªåˆçº¦å¿…é¡»å®ç° onERC721Received(address,address,uint256,bytes) æ–¹æ³•
6. transferFrom äº¤æ˜“é€»è¾‘ä¸ safeTransferFrom ä¸€æ ·ï¼Œåªä¸è¿‡ safeTransferFrom åˆ¤æ–­äº† to çš„åœ°å€
7. function setApprovalForAll(address _operator, bool _approved) external;
* _approved ä¸º true è¡¨ç¤ºæˆæƒï¼Œä¸º false è¡¨ç¤ºæ”¶å›æˆæƒ
8. getApproved æŸ¥è¯¢æˆæƒç»™è°
9. function isApprovedForAll(address _owner, address _operator) external view returns (bool);
* æŸ¥è¯¢ _owner æ˜¯ä¸æ˜¯å…¨æƒå§”æ‰˜ç»™ _operator

### interface ERC165
interfaceID å³ä¸€ä¸ª interface é‡Œæ‰€æœ‰å‡½æ•°å–å®Œâ€œå‡½æ•°å‰ 4 ä¸ªå­—èŠ‚ï¼Œ
å³å‡½æ•°ç­¾åâ€ï¼ˆç±»ä¼¼ bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))ï¼‰ï¼Œ
æ¯ä¸ªå‡½æ•°éƒ½æœ‰ä¸€ä¸ªå‡½æ•°ç­¾åï¼Œå°†è¿™ä¸ª interface é‡Œæ‰€æœ‰å‡½æ•°ç­¾åè¿›è¡Œäº¦æˆ–ï¼Œå¾—åˆ°è¿™ä¸ª interface çš„ interfaceIDã€‚

ERC165 å®é™…æ˜¯å®ç° function supportsInterface(bytes4 interfaceID) external view returns (bool);
è¿›è¡Œ interfaceID çš„æ³¨å†Œ


Tips
{% highlight ruby %}
æ“ä½œé’±æ—¶å€™è¦æ³¨æ„åœ°å€æ˜¯å¦æ˜¯ 0ï¼Œä¸è¦æŠŠé’±è½¬è¿›é»‘æ´
require(msg.sender != address(0), "address must be not 0");
{% endhighlight %}


### å‚è€ƒé“¾æ¥
{% highlight ruby %}
https://eips.ethereum.org/EIPS/eip-20
https://docs.openzeppelin.com/
{% endhighlight %}

